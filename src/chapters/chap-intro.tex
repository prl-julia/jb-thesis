\chapter{Introduction}

Julia is a dynamic, high-level, high-performance programming
language~\cite{bib:bezanson:julia-fresh:2017},
originally designed for scientific computing.
Julia aims to solve the two-language problem, combining the convenience of
productivity languages such as Python and R and the performance of languages
such as Fortran and C~\cite{bib:bezanson:julia-dyn-perf:oopsla:2018}.
Notably, despite the lack of a static type system,
Julia supports an expressive language of type annotations, which have a direct 
impact on program semantics. In particular, function call resolution relies on 
subtyping between run-time types and type annotations.
However, the subtype relation is undecidable, which causes some programs to
fail at run time with an uninformative \cjl{StackOverflowError}.
In this thesis, I propose a restriction on the undecidable fragment of
Julia types, define a decidable subtype relation for the restricted fragment,
and show that the impact of the restriction on the existing code is limited.
\TODO{more info/update}


\section{Subtyping in Julia}
%% ======================================================================

To encourage a high level of code reuse and extensibility,
Julia is designed around \emph{symmetric multiple dynamic dispatch}.
Multiple dispatch allows a function to have multiple implementations, called
methods, tailored to different argument types; at run time, a function
call is dispatched to the most specific method for the given arguments.
%Thus, with multiple dispatch, programmers can write code
% \TODO{generic code plus optimized special cases}

To deliver performance, Julia relies on a type-specializing just-in-time (JIT)
compiler: with few exceptions\footnote{%
\url{https://docs.julialang.org/en/v1/manual/performance-tips/\#Be-aware-of-when-Julia-avoids-specializing}
}, %~\cite{TODO}, link to Julia docs on avoiding specialization
every time a method is called with a new set of argument types,
it is specialized for those types, creating a new method
definition~\cite{bib:pelenitsyn:type-stability:oopsla:2021}.
Therefore, even for functions with a single user-defined method,
more methods can accrue during the program execution,
adding work for the dispatch mechanism.

% Thus, although Julia is dynamically typed and does not require
% programmers to provide type annotations,
% types have a profound role in the language semantics and performance.

Multiple dispatch is resolved with the use of a subtype relation.
Namely, for every function call, subtyping is checked between
the argument types and method type signatures,
as well as between method type signatures.
While most run-time value types are nominal, %e.g. \cjl{Vector\{Int64\}},
the language of type annotations is more complex and expressive. 
In particular, inspired by semantic subtyping
where types are interpreted as sets,
Julia supports covariant tuples that distribute over unions.
For example, according to the semantic approach, the type 
\cjl{Tuple\{String, Union\{Int64, UInt64\}\}} represents a set of binary
tuples where the first component is either a signed or unsigned integer,
and the second component is a string. Therefore, both
\cjl{Tuple\{String, Int64\}} and \cjl{Tuple\{String, UInt64\}} are subtypes
of the above type, and that type is equivalent to the union of the two
tuples, \cjl{Union\{Tuple\{String, Int64\}, Tuple\{String, UInt64\}\}}.
In addition to finite unions, Julia supports existential types, referred to as
union-all types or iterated unions in the language. 
For example, \cjl{Vector\{T\} where T}
represents an infinite union of vectors \cjl{Vector\{t\}} for all valid
instantiations \cjl{t} of the type variable \cjl{T}.
A~more detailed account of Julia types and subtyping
is provided in~\chapref{chap:background}.
% to represent parametric method definitions
%choosing an unusual combination of type language features.

Despite intentional simplifications in the type language,
e.g. the lack of recursive bounds on type variables,
subtyping in Julia is
\emph{undecidable}~\cite{bib:chung:type-julia-thesis:2023}.
%due to %the support for
%impredicative bounded existential types.
%Simply disallowing such types would not be practical,
%as Julia users rely on them to describe heterogeneous data.
% For example, \cjl{Vector\{Vector\{T\} where T<:Number\}}
% describes a heterogeneous vector of vectors of numeric values
% where inner vectors can have different element types.
Although relying on undecidable subtyping is not unprecedented
for a statically typed language, e.g. Scala~\cite{bib:hu:dot-undec:2020},
%with an expressive type system such as
the price of undecidability
is higher in Julia, since it
can manifest at almost any point during the program \emph{execution}.
%as subtyping over a complex language of run-time types and type annotations
%is an integral part of Julia's dynamic semantics.
Namely, the run-time system relies on undecidable subtyping
to resolve function calls,
process new method definitions~\cite{bib:belyakova:world-age:oopsla:2020},
manipulate data (e.g. when adding an element to a container),
as well as during JIT compilation~\cite{bib:pelenitsyn:type-stability:oopsla:2021}.
In practice, the undecidability
leads to a run-time crash with a \cjl{StackOverflowError}.
Such an issue can be particularly hard to debug,
because the error is uninformative: neither the problematic subtyping query
nor stack trace is reported.

A number of issues related to subtyping have been reported
on the Julia bug tracker. For example,
\href{https://github.com/JuliaLang/julia/issues/41948}{\code{\#41948}}\footnote{
    \url{https://github.com/JuliaLang/julia/issues/41948}
} reports a \cjl{StackOverflowError} caused by a function definition,
which is likely linked to undecidability;
\href{https://github.com/JuliaLang/julia/issues/33137}{\code{\#33137}}\footnote{
    \url{https://github.com/JuliaLang/julia/issues/33137}
} points out an inconsistency in subtyping; % related to the diagonal rule.
\href{https://github.com/JuliaLang/julia/issues/24166}{\code{\#24166}}\footnote{
    \url{https://github.com/JuliaLang/julia/issues/24166} 
} (now fixed) reports a problem with reflexivity and transitivity.
Overall, there are 105 open/704 closed issues labeled with ``types and
dispatch'' as of March 2023,
with 13 open/138 closed being also labeled with ``bug''
(not every issue is properly labeled as a bug,
e.g. the aforementioned
\href{https://github.com/JuliaLang/julia/issues/24166}{\code{\#24166}} is not).
\tabref{tab:julia-issues-stats} provides a few more data points for comparison:
for example, there are 8 open/86 closed ``codegen'' bugs
and 1 open/15 closed ``GC'' bugs.
Thus, type-related concerns, including the undecidability of subtyping,
are not purely theoretical and
constitute a non-negligible portion of problems in the Julia implementation.

\begin{table}[t]
\begin{threeparttable}
\centering\footnotesize
\begin{tabular}{c|ccccc}
 & types and dispatch & codegen & GC & macros & <any label> \\
\midrule
<any label> &
  92/414 & 56/246 & 24/51 & 27/36 & 3551/19238 \\
bug &
  13/138 & 8/86 & 1/15 & 5/11 & 226/2664
\end{tabular}
\caption{Open/closed issues on the Julia bug tracker
(March~2023)}\label{tab:julia-issues-stats}
\begin{tablenotes}[para]
\small
Axes represent labels the issues are marked with: for example, the cell
24/51 in the row \emph{<any label>} and column \emph{GC} corresponds to all
issues labeled with {``GC''}, whereas 1/15 in the row \emph{bug} and column 
\emph{GC} corresponds to {``GC''} issues that are also labeled with {``bug''}.
\end{tablenotes}
\end{threeparttable}
\end{table}

\section{Thesis and Contributions}
%% ======================================================================

Due to Julia's ubiquitous use of subtyping at run time,
the undecidability of subtyping is consequential.
Unfortunately, as I discuss in \chapref{sec:julia-sub:undec},
a compatible decidable subtype relation for the entirety of Julia types
is unlikely to exist.
However, my thesis is that
\begin{quotation}\emph{
  the Julia language can be evolved to provide for decidable subtyping while
  requiring minimal effort for migrating existing code.
}\end{quotation}

Because the type language and its associated subtype relation 
impact the set of valid Julia programs and their dynamic semantics,
replacing subtyping can have profound effects on programmer experience 
as well the ability to migrate existing code.
Thus, not any decidable subtyping would be a viable candidate for
Julia's evolution.

In this dissertation, I show that there is
a restriction on Julia's type language that allows for decidable subtyping
and supports 99.99\% of statically identifiable type annotations
in registered Julia packages.
Namely, the restriction limits existential types inside invariant constructors
to existential types expressible with use-site variance,
similar to Java wildcards~\cite{bib:torgersen:wildcards:2004}.

The dissertation provides an overview of Julia
(Chapters \ref{chap:background} and \ref{sec:julia-sub:overview})
and makes the following contributions:
\begin{itemize}
  \item \textbf{Specification of Julia
    subtyping}~\citep*{bib:zappa-nardelli:julia-sub:oopsla:2018}
    (\chapref{sec:julia-sub:lambda-julia}).
    The specification covers most of Julia, with the only exception being
    variable-length tuples.
  \item \textbf{Decidable subtyping} for a restricted language of Julia 
    types~[a collaboration with Ross Tate] (\chapref{chap:dec-sub}).
    The restriction retains most of Julia types, limiting only existential types
    inside invariant constructors.
  \item \textbf{Evaluation of migration effort} required to switch to 
    the restricted type language (\chapref{chap:eval}). 
    In the corpus of all 9K registered Julia packages, 99.99\% of source code 
    type annotations satisfy the restriction.
\end{itemize}
\TODO{mention my other work that's related}
