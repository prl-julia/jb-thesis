\chapter{Background}

\section{Overview of the Julia Language}
%% ======================================================================

Julia is a high-level, dynamic programming language for scientific computing~\cite{TODO}.
It was designed to provide good performance as well as productivity features and
the ease of use~\cite{TODO}.
For performance, Julia relies on an optimizing JIT compiler.
For productivity, the language provides garbage collection, dynamic typing, and
multiple dispatch. 

\begin{figure}[t]
%-(x::Date, y::Week) = Date(UTD(value(x) - 7*value(y)))    
\begin{julia}
-(x::BigInt) = MPZ.neg(x, y)
-(x::BigInt, y::BigInt) = MPZ.sub(x, y)
-(x::T, y::T) where T<:Union{Int16, Int32, ..., UInt128} = sub_int(x, y)
-(m::Missing, n::Number) = missing
-(A::AbstractArray{T,N} where {T,N}) = broadcast_preserving_zero_d(-, A)
\end{julia}
\caption{Several method definitions of generic function~\cjl{(-)}
in~Julia}\label{fig:code:subtraction}
\end{figure}

\tdef{Multiple dynamic dispatch}~\cite{TODO} is the core paradigm of the Julia
language. The dispatch mechanism allows a function, called \emph{generic
function}, to have multiple implementations, called \emph{methods}, that are
tailored to different argument types. For example, \figref{fig:code:subtraction}
shows several method definitions of \cjl{(-)}, which is used as both unary
negation (lines~1 and 5) and binary subtraction (lines 2--4).
At \emph{run time}\footnote{Statically typed languages often support
\emph{method overloading}. The difference between method overloading and method
dispatch is that overloading is resolved at compile time, using static types of
the arguments, whereas dispatch is resolved at run-time, using precise types
of the arguments.},
every function call in the program is dispatched to the
\emph{most specific applicable} method, which is determined based on the
types of the argument values. If such a single best method does not exist,
an error is raised.
\secref{sec:2:dispatch} describes this process in more detail, but for now,
it suffices to know that dispatch resolution relies on \tdef{subtyping}.
Notably, Julia does not allow the user to call a method of a generic function
directly: the only way to reach a method is via the dispatch mechanism.
Thus, whenever a method is called, its arguments are guaranteed to be
subtypes of the declared type annotations.
%Thus, types impact the semantics of a program despite the language being dynamically typed.

Julia has a non-trivial \tdef{language of types} \ty, some of which are
demonstrated in~\figref{fig:code:subtraction}. In addition to nominal types such
as \cjl{BigInt} and \cjl{Number}, the language also supports set-theoretic union
types (e.g. \cjl{Union\{Int16, ..., UInt128\}} in line~3),
covariant tuple types written with \cjl{Tuple} (e.g. \cjl{Tuple\{String, Number\}}),
invariant parametric types (e.g. \cjl{Vector\{T\}}),
and so-called union-all types, which are written with \cjl{where} (lines~3 and 5).
A union-all type \cjl{t where T} represents a union of types \cjl{t} for all
valid instantiations of the type variable \cjl{T}. \citet{TODO} provide a detailed
account of Julia types and their subtyping relation, and we give a brief
overview of subtyping in \secref{sec:2:subtyping}.

One of the key notions related to types in Julia is the distinction between
\emph{concrete} and \emph{abstract} types. A concrete type \gty is a type that
describes the representation of a value; for any value, its concrete type can be
obtained with the \cjl{typeof} operator. Concrete types include primitive types
such as \cjl{Int128} and composite \cjl{struct} types (either mutable or
immutable). Any concrete type definition in Julia is final: a concrete type does
not have subtypes other than itself. However, every concrete type has a single
declared supertype, which is an abstract nominal type. Such types can be used
to create a nominal subtyping hierarchy, but they cannot be instantiated with
values and have no fields. Other categories of abstract types are union types
such as \cjl{Union\{Int16,}$\ldots$\cjl{, UInt128\}}, and union-all types
such as \cjl{Vector\{T\} where T} (in Julia, such a type can be written shorter
as \cjl{Vector}). Note, however, that every particular instantiation of
\cjl{Vector}, e.g. \cjl{Vector\{Number\}}, is a concrete type.
The bottom type represented with the empty union, \cjl{Union\{\}}, is neither
concrete nor abstract: it has no values and is a subtype of all types.

\figref{fig:code:user-def-types} provides several examples of user-defined
concrete (on the left) and abstract (on the right) types. Parametric types (both
abstract and concrete) can declare lower and upper bounds on type variables;
for example, type \cjl{Rational\{T\}} requires \cjl{T} to be a subtype of
abstract \cjl{Integer}.
Supertypes in type definitions are declared to the right of~\cjl{<:}.
For example, \cjl{Int128} is a subtype of \cjl{Signed}, and \cjl{Signed} is a
subtype of \cjl{Integer}. If the supertype declaration is omitted, like in
\cjl{AbstractSet\{T\}}, the supertype defaults to \cjl{Any},
which is the supertype of all types.

It is worth noting that the language does not have a function type that would
typically be written as \cjl{T} $\rightarrow$ \cjl{S}. As mentioned above,
all function calls are dynamically dispatched to a method of the generic
function, and there is no way to directly call or
pass a particular method as an argument.
Generic functions, on the other hand, are first-class values and can be used as
method arguments, for example, \cjl{(-)} is passed to a function call in line~5
of~\figref{fig:code:subtraction}.
Every generic function~\cjl{f} has the concrete type \cjl{typeof(f)},
which is a subtype of the type of all functions \cjl{Function}.

\begin{figure}[t] 
\begin{minipage}{5.5cm}
\begin{julia}
primitive type Int128 <: Signed 128
end

struct Rational{T<:Integer} <: Real
  num::T
  den::T
end

mutable struct
  BitSet <: AbstractSet{Int}
  ...
end
\end{julia}
% struct Missing end
% bits::Vector{UInt64}
% offset::Int
\end{minipage}
\hspace{1.2cm}
\begin{minipage}{4.8cm}
\begin{julia}
abstract type Signed <: Integer
end

abstract type AbstractSet{T}
end
\end{julia}
% RefValue{T}() where {T} = new()
% RefValue{T}(x) where {T} = new(x)    
\end{minipage}
\caption{Examples of type definitions:
  concrete (left) and abstract (right)}\label{fig:code:user-def-types}
\end{figure}


\section{Multiple dispatch resolution}\label{sec:2:dispatch}
%% ======================================================================

Method resolution for a dispatched function call \cjl{f(a1, a2, ...)}
relies on subtyping between run-time argument types and method type signatures.
Argument types are combined into a tuple of concrete types
$\gty =$ \cjl{Tuple\{typeof(a1), typeof(a2), ...\}}.
Method type signature is a tuple of the declared argument types
if the method definition is not parametric, and a union-all of a tuple
if the definition is parametric.
For example, in \figref{fig:code:subtraction}, method in line~1
has the signature \cjl{Tuple\{BigInt\}}, line~4 has the signature
\cjl{Tuple\{Missing,Number\}}, and line~3 has the signature
\cjl{Tuple\{T, T\} where T <: Union\{...\}}.
Thus, for the purpose of dispatch resolution, arguments of a function call
are represented with a single concrete type \gty,
and method type signature is represented as an arbitrary type \ty.

Dispatch resolution, if successful, returns the \emph{most specific applicable
method}. Namely, for a call to generic function~\cjl{f} with the argument
type~\gty, the process can be specified as follows:
\begin{enumerate}
  \item Find all applicable methods, i.e., all method signatures \ty of the
    function~\cjl{f} such that $\gty <: \ty$ (argument type is a subtype of the
    method signature).
    If no methods are applicable, a method-not-found error is raised.
  \item Among the applicable methods $\{\ty_1, \ldots, \ty_n\}$,
    pick the method with the most specific type signature,
    i.e., $\ty_k$ such that $\forall i\in1..n, \ty_k <: \ty_i$ 
    (method type signature is a subtype of all other applicable method
    signatures). If there is no such single best method, a method-is-ambiguous
    error is raised.\footnote{Julia has extra specificity rules
    to resolve ambiguities in some cases requested by users,
    but those are not relevant to this work.}
\end{enumerate}
Julia's dispatch mechanism is \emph{symmetric}: all arguments are given
equivalent consideration as a part of subtyping of tuples.

While there are ways to optimize dispatch resolution to limit the number of
subtyping checks, the key takeaway from this section is that
in Julia, \emph{subtyping happens at run time} as a part of dynamic dispatch.
Furthermore, the following section will show that because of invariant
constructors and union-all types, even subtyping with a concrete type on the left
(i.e., $\gty <: \ty$) can require an arbitrary subtyping check $\ty_1 <: \ty_2$.

\section{Julia subtyping}\label{sec:2:subtyping}
%% ======================================================================

Subtyping in Julia largely follows the combination of
\tdef{nominal subtyping} between user-defined nominal types and
\tdef{semantic subtyping} for covariant tuple and union types.
Thus, using types from \figref{fig:code:user-def-types} as an example,
\cjl{Int128} is a subtype of \cjl{Signed}, and, transitively, of \cjl{Integer};
\cjl{BitSet} is a subtype of \cjl{AbstractSet\{Int\}} but not
\cjl{AbstractSet\{String\}}.
A~union type \cjl{Union\{t1, t2, ...\}} describes a set-theoretic union of
types \cjl{t1}, \cjl{t2}, \cjl{...}, so, for example, \cjl{Int} is a subtype of
\cjl{Union\{Signed, String\}}, and \cjl{Union\{t1, t2, ...\} <: t} if all
components \cjl{t1 <: t, t2 <: t, ...}.
Tuples in Julia are immutable, and tuple types are covariant:
\cjl{Tuple\{t1, t2, ...\}} is a subtype of \cjl{Tuple\{t1', t2'...\}} if
their corresponding components are subtypes, i.e., \cjl{t1 <: t1', t2 <: t2', ...}.
Following semantic subtyping, tuple types distribute over unions,
so types \cjl{Tuple\{Union\{Int,String\}\}} and
\cjl{Union\{Tuple\{Int\},Tuple\{String\}\}} are equivalent.

User-defined parametric types are invariant regardless of whether the type is
mutable or immutable, meaning that \cjl{Name\{t11, t12, ...\}} is a subtype of 
\cjl{Name\{t21, t22, ...\}} only if corresponding type parameters are equivalent,
i.e., \cjl{t11 <:> t21, t21 <:> t22, ...}.
Thus, while covariant \cjl{Tuple\{Int\} <: Tuple\{Signed\}},
invariant \cjl{Rational\{Int\}} is \emph{not}
a subtype of \cjl{Rational\{Signed\}}.

Union-all types \cjl{t where tl<:T<:tu} are better known in literature as
\tdef{bounded existential types}, which also model
Java wildcards~\cite{TODO}\footnote{In Julia syntax, a Java wildcard type
\cjl{Foo<?>} can be written as \cjl{Foo\{T\} where T}.}.
In what follows, we will call \cjl{t where tl<:T<:tu} an existential type;
if lower (upper) bound on the type variable is omitted, it defaults to the
bottom type \cjl{Union\{\}} (top type \cjl{Any}).
Intuitively, an existential type denotes a union of \cjl{t[t'/T]} for all
instantiations of \cjl{T} such that \cjl{tl <: t' <: tu}.
Similarly to subtyping for union types,
\begin{itemize}
  \item \cjl{(t where tl<:T<:tu) <: t2} if \emph{for all} valid instantiations
    \cjl{t'} it holds that \cjl{t[t'/T] <: t2}, and
  \item \cjl{t1 <: (t where tl<:T<:tu)} if \emph{there exists} at least one 
    \cjl{t'} such that \cjl{t1 <: t[t'/T]}.
\end{itemize}
For example, \cjl{Vector\{Int\}} is a subtype of \cjl{Vector\{T\} where T}
because \cjl{T} can be instantiated with \cjl{Int}.
Just like with unions, tuple types distribute over existential types:
for example, types \cjl{Tuple\{Vector\{T\} where T\}}
and \cjl{Tuple\{Vector\{T\}\} where T} are equivalent.

Type signatures of parametric method definitions are represented as existential
types. Just like with Java wildcards, there are no explicit packing and
unpacking operations: \TODO{somethig about implicit packing}.

