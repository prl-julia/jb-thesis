\chapter{Julia Subtyping}%
\label{chap:julia-sub}

\TODO{Intro, reference lambda-julia}

\section{Overview}\label{sec:julia-sub:overview}
%% ======================================================================

Subtyping in Julia largely follows the combination of
\tdef{nominal subtyping} for user-defined nominal types and
\tdef{semantic subtyping} for covariant tuple and union types.
For example, using types from \figref{fig:code:user-def-types}, we note that
\cjl{Int128} is a subtype of \cjl{Signed}, and, transitively, of \cjl{Integer};
\cjl{BitSet} is a subtype of \cjl{AbstractSet\{Int\}}.
%but not \cjl{AbstractSet\{String\}}.
A~union type \cjl{Union\{t1, t2, ...\}} describes a set-theoretic union of
types \cjl{t1}, \cjl{t2}, \cjl{...}; for example, \cjl{Int} is a subtype of
\cjl{Union\{Signed, String\}}, and \cjl{Union\{t1, t2, ...\} <: t} if all
components \cjl{t1 <: t, t2 <: t, ...}.
Tuples in Julia are immutable, and tuple types are covariant:
\cjl{Tuple\{t1, t2, ...\}} is a subtype of \cjl{Tuple\{t1', t2'...\}} if
their corresponding components are subtypes, i.e., \cjl{t1 <: t1', t2 <: t2', ...}.
Following semantic subtyping, tuple types distribute over unions,
so types \cjl{Tuple\{Union\{Int,String\}\}} and
\cjl{Union\{Tuple\{Int\},Tuple\{String\}\}} are equivalent.

User-defined parametric datatypes are invariant in the type parameter
regardless of whether the datatype is
mutable or immutable, meaning that \cjl{Name\{t11, t12, ...\}} is a subtype of 
\cjl{Name\{t21, t22, ...\}} only if the corresponding type arguments are equivalent,
i.e., \cjl{t11 <:> t21}, \cjl{t21 <:> t22, ...}.
Thus, the immutable invariant datatype \cjl{Rational\{Int\}} is \emph{not}
a subtype of \cjl{Rational\{Signed\}}.
%while the covariant tuple \cjl{Tuple\{Int\} <: Tuple\{Signed\}}.

Abstract union-all types \cjl{t where tl<:T<:tu} are better known
in the literature as \tdef{bounded existential types}, which also model
Java wildcards~\cite{torgersen:wildcards:2004}\footnote{In Julia syntax, 
a Java wildcard type
\cjl{Foo<?>} can be written as \cjl{Foo\{T\} where T}.}.
In what follows, we will call types \cjl{t where tl<:T<:tu} existential types;
if lower (upper) bound on the type variable is omitted, it defaults to the
bottom type \cjl{Union\{\}} (top type \cjl{Any}).
Intuitively, an existential type denotes a union of \cjl{t[t'/T]} for all
instantiations of the type variable \cjl{T} such that \cjl{tl <: t' <: tu}.
Similarly to subtyping of finite union types, the intent is that:
\begin{itemize}
  \item \cjl{(t where tl<:T<:tu) <: t2} if \emph{for all} valid instantiations
    \cjl{t'}, it holds that \cjl{t[t'/T] <: t2}, and
  \item \cjl{t1 <: (t where tl<:T<:tu)} if \emph{there exists} at least one 
    \cjl{t'} such that \cjl{t1 <: t[t'/T]}.
\end{itemize}
For example, \cjl{Vector\{Int\}} is a subtype of \cjl{Vector\{T\} where
T<:Integer} because \cjl{T} can be instantiated with \cjl{Int},
and \cjl{Vector\{T\} where T<:Integer} is a subtype of
\cjl{Vector\{S\} where S} because for all valid instantiations \cjl{t'} of~\cjl{T},
type variable \cjl{S} can be instantiated with the same type \cjl{t'}.
Just like unions, existential types distribute over tuples:
for example, types \cjl{Tuple\{Vector\{T\} where T\}}
and \cjl{Tuple\{Vector\{T\}\} where T} are equivalent.

Existential types in Julia are \emph{impredicative}:
existential quantifiers can appear anywhere in a type,
and type variables can be instantiated with arbitrary existential types.
For example, type \cjl{Vector\{Matrix\{T\} where T\}} denotes a vector
of matrices with arbitrary element types.
In contrast, \cjl{Vector\{Matrix\{S\}\} where S} denotes a set of vectors where
elements are matrices with the same element type.
Thus, a vector of integer matrices \cjl{Vector\{Matrix\{Int\}\}} is a subtype
of the latter---existential---type, because \cjl{S} can be instantiated with
\cjl{Int}. But it is not a subtype of the former---invariant parametric---type
\cjl{Vector\{Matrix\{T\} where T\}}, because type arguments \cjl{Matrix\{Int\}}
and \cjl{Matrix\{T\} where T} are not equivalent.
\TODO{Explain the following better: Benjamin had questions.}
Note that because of the impredicativity, type arguments of invariant type
constructors such as \cjl{Vector} are arbitrarily complex. Thus, even though any
particular \cjl{Vector\{t\}} is a concrete type, checking subtyping for this
type requires a subtyping check for an arbitrary \cjl{t}.

Existential types serve at least two distinct purposes in the Julia language.
First, parametric types with existential parameters,
such as \[\text{\cjl{Vector\{Matrix\{T\} where T\}}},\]
are useful for representing heterogeneous data.
Second, top-level existential types, such as
\[\text{\cjl{Tuple\{T, Vector\{T\}\} where T}},\] represent
type signatures of parametric method definitions.
It may be surprising that Julia uses existential rather than universal types,
but recall that the primary purpose of types is to serve multiple dispatch.
In Julia, it is impossible to directly invoke a parametric method definition
and provide it with a type argument. Instead, the method is being dispatched to if
subtyping for the corresponding existential type succeeds. Then, in the body of
the method, the existential type is implicitly unpacked, with the witness type
being some valid instantiation induced by subtyping.
Consider the following code snippet as an example:
\begin{codeenvd}
\begin{julia}
f(v :: Vector{T}) where T = 
    Set{T}(v)

f([5, 7, 5]) # returns Set{Int} with 2 elements: 5, 7
\end{julia}
\end{codeenvd}
Because \cjl{[5, 7, 5]} is a \cjl{Vector\{Int\}} and
\cjl{Tuple\{Vector\{Int\}\}} is a subtype of the existential
\cjl{Tuple\{Vector\{T\}\} where T},
as witnessed by the instantiation of \cjl{T} with \cjl{Int},
the call \cjl{f([5, 7, 5])} dispatches to the method in line~1,
and \cjl{T} in the body of the method becomes \cjl{Int}.
However, when multiple instantiations of the variable are possible,
Julia sometimes gives up on assigning the witness type.
In the example below, subtyping succeeds for the call \cjl{g(true)},
because \cjl{Tuple\{Bool\}} is a subtype of \cjl{Tuple\{T\} where T>:Int}:
there are, in fact, multiple possible instantiations \cjl{t} of \cjl{T}
such that \cjl{Tuple\{Bool\} <: Tuple\{t\}},
e.g. \cjl{Any} or \cjl{Union\{Int, Bool\}}.
But rather than pick one instantiation, Julia throws an error:
\begin{codeenvd}
\begin{julia}
> g(x::T) where T>:Int = begin
    println(x)
    println(T)
  end

> g(true)
true
ERROR: UndefVarError: T not defined
\end{julia}
\end{codeenvd}
On the other hand, for the call \cjl{g(5)}, \cjl{T} is assigned the smallest
possible type, \cjl{Int}:
\begin{codeenvd}
\begin{julia}
> g(5)
5
Int
\end{julia}
\end{codeenvd}

Subtyping of existential types includes a special case, called 
the \tdef{diagonal rule}, which provides the support for
a generic programming pattern where method arguments are expected
to be of the same concrete type.
Consider the following method definition, which defines equality
\cjl{(==)} in terms of the built-in equality of bit representations \cjl{(===)}:
\begin{codeenvd}
\begin{julia}
==(x::T, y::T) where T<:Number = x === y
\end{julia}
\end{codeenvd}
If it were possible to instantiate \cjl{T} with an abstract type such as
\cjl{Integer}, the method could be called with a pair of a signed and unsigned
integer. This would be an incorrect implementation of equality, for the same bit
representation corresponds to different numbers when interpreted with and
without the sign.
To prevent such behavior, the diagonal rule states: if a type variable
appears in the type (1) only covariantly and (2) more than once,
it can be instantiated
only with concrete types.\footnote{A similar rule applies to static resolution
of method overloading in \CSharp. An example can be found on this page:
\href{https://fzn.fr/projects/lambdajulia/diagonalcsharp.pdf}{https://fzn.fr/projects/lambdajulia/diagonalcsharp.pdf}}
Thus, the type signature of \cjl{(==)} above,
\cjl{Tuple\{T, T\} where T<:Number}, represents a restricted existential type:
it is a union of tuples \cjl{Tuple\{t, t\}} where \cjl{t} is a concrete subtype
of \cjl{Number}. The same rule applies in line~3
of~\figref{fig:code:subtraction}: built-in integer subtraction \cjl{sub_int} is
guaranteed to be called only with primitive integers of the same concrete type.

\section{Specification of Julia Subtyping}\label{sec:julia-sub:lambda-julia}
%% ======================================================================

\TODO{Lambda-Julia}

\section{Undecidability of Julia Subtyping}\label{sec:julia-sub:undec}
%% ======================================================================

\begin{figure}
\[
\begin{array}{rcl}
  \interp{\mathit{Top}} &=& \text{\cjl{Union\{\}}}\\
  \interp{\alpha} &=& \alpha\\
  \interp{\forall\alpha\leq\ty.\ty'} &=&
    \text{\cjl{Tuple\{Ref\{}}\alpha\text{\cjl{\}, }}
    \interp{\ty'}\text{\cjl{\} where\ }}\alpha\text{\cjl{\ >:\ }}\interp{\ty}\\
\end{array}
\]
\caption{Encoding of \FSubN types in Julia}\label{fig:FSub-encoding}
\end{figure}

It is not unusual for a statically typed programming language 
to have undecidable subtyping,
as witnessed by Java and Scala~\cite{grigore:java-undec:2017,hu:dot-undec:2020}.
In practice, the undecidability means that the
compiler might not terminate on some programs. Although undesirable,
such property can be acceptable if it manifests rarely and
allows for an expressive type system.

In a dynamically typed Julia, however, subtyping is used at run time---for
dispatch resolution. Even on rare occasions, consequences of
undecidability at run time are of greater concern than at compile time.
That is why the decidability of subtyping was one of the explicit goals
of the original design of the Julia language~\cite{bib:bezanson:julia:2015}.
To this end, Julia disallowed several features that were known to cause
undecidability, such as recursive constraints on type variables and
circularities in the inheritance hierarchy~\cite{tate:taming-wildcards:2011}.

Despite the intentional simplifications in the type language,
Julia subtyping is in fact \emph{undecidable}.
As shown in~\TODO{Ben's thesis}, Julia can encode system
\FSubN, which is known to be undecidable~\cite{pierce:bound-sub-undec:1992}.
\figref{fig:FSub-encoding} shows the encoding\footnote{Arrow %of \FSubN types
type is dropped as irrelevant to the undecidability result.},
with $\ty_1 \leq \ty_2$ in \FSubN defined as
$\interp{\ty_2} <: \interp{\ty_1}$ in Julia.
In practice, the undecidability %of Julia subtyping 
manifests itself with a \cjl{StackOverflowError}.
The reason is that internally, Julia relies on a dedicated stack
to resolve subtyping
and terminates the program when the stack reaches a certain limit.
%Thus, in practice, subtyping checks that showcase undecidability, such as
%the Ghelli example, often manifest with a \cjl{StackOverflowError}
%rather than non-termination.

Although the undecidability of a particular subtyping algorithm
does not necessarily mean that decidable subtyping for the same
language of types does not exist, I \emph{conjecture} that
\begin{quotation}\emph{
  there is no decidable subtype relation for Julia's language of types
  that would agree with the intended subtyping judgments
  described in \secref{sec:julia-sub:overview}.\TODO{be more careful here}
}\end{quotation}
The problem lies in the interaction of
impredicative existential types, invariant constructors, and unions.

\TODO{consider the example from the proposal}
