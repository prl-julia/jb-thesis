\chapter{Julia Subtyping}%
\label{chap:julia-sub}

\TODO{Intro, reference lambda-julia}

\section{Overview}\label{sec:julia-sub:overview}
%% ======================================================================

Subtyping in Julia largely follows the combination of
\tdef{nominal subtyping} for user-defined nominal types and
\tdef{semantic subtyping} for covariant tuple and union types.
For example, using types from \figref{fig:code:user-def-types}, we note that
\cjl{Int128} is a subtype of \cjl{Signed}, and, transitively, of \cjl{Integer};
\cjl{BitSet} is a subtype of \cjl{AbstractSet\{Int\}}.
%but not \cjl{AbstractSet\{String\}}.
A~union type \cjl{Union\{t1, t2, ...\}} describes a set-theoretic union of
types \cjl{t1}, \cjl{t2}, \cjl{...}; for example, \cjl{Int} is a subtype of
\cjl{Union\{Signed, String\}}, and \cjl{Union\{t1, t2, ...\} <: t} if all
components \cjl{t1 <: t, t2 <: t, ...}.
Tuples in Julia are immutable, and tuple types are covariant:
\cjl{Tuple\{t1, t2, ...\}} is a subtype of \cjl{Tuple\{t1', t2'...\}} if
their corresponding components are subtypes, i.e., \cjl{t1 <: t1', t2 <: t2', ...}.
Following semantic subtyping, tuple types distribute over unions,
so types \cjl{Tuple\{Union\{Int,String\}\}} and
\cjl{Union\{Tuple\{Int\},Tuple\{String\}\}} are equivalent.

User-defined parametric datatypes are invariant in the type parameter
regardless of whether the datatype is
mutable or immutable, meaning that \cjl{Name\{t1, t2, ...\}} is a subtype of 
\cjl{Name\{t1', t2', ...\}} only if the corresponding type arguments are equivalent,
i.e., \cjl{t1 <:> t1'}, \cjl{t2 <:> t2', ...}.
Thus, the immutable invariant datatype \cjl{Rational\{Int\}} is \emph{not}
a subtype of \cjl{Rational\{Signed\}}.
%while the covariant tuple \cjl{Tuple\{Int\} <: Tuple\{Signed\}}.

Abstract union-all types \cjl{t where l<:T<:u} are better known
in the literature as \tdef{bounded existential types}, which also model
Java wildcards~\cite{bib:torgersen:wildcards:2004}\footnote{In Julia syntax, 
a Java wildcard type
\cjl{Foo<?>} can be written as \cjl{Foo\{T\} where T}.}.
In what follows, we will call types \cjl{t where l<:T<:u} existential types;
if lower (upper) bound on the type variable is omitted, it defaults to the
bottom type \cjl{Union\{\}} (top type \cjl{Any}).
Intuitively, an existential type denotes a union of \cjl{t[t'/T]} for all
instantiations of the type variable \cjl{T} such that \cjl{l <: t' <: u}.
Similarly to subtyping of finite union types, the intent is that:
\begin{itemize}
  \item \cjl{(t where l<:T<:u) <: t2} if \emph{for all} valid instantiations
    \cjl{l<:t'<:u}, it holds that \cjl{t[t'/T] <: t2}, and
  \item \cjl{t1 <: (t where l<:T<:u)} if \emph{there exists} at least one 
    \cjl{l<:t'<:u} such that \cjl{t1 <: t[t'/T]}.
\end{itemize}
For example, \cjl{Vector\{Int\}} is a subtype of \cjl{Vector\{T\} where
T<:Integer} because \cjl{T} can be instantiated with \cjl{Int},
and \cjl{Vector\{T\} where T<:Integer} is a subtype of
\cjl{Vector\{S\} where S} because for all valid instantiations \cjl{t'} of~\cjl{T},
type variable \cjl{S} can be instantiated with the same type \cjl{t'}.
Just like unions, existential types distribute over tuples:
for example, types \cjl{Tuple\{Vector\{T\} where T\}}
and \cjl{Tuple\{Vector\{T\}\} where T} are equivalent.

Existential types in Julia are \emph{impredicative}:
existential quantifiers can appear anywhere in a type,
and type variables can be instantiated with arbitrary existential types.
For example, type \cjl{Vector\{Matrix\{T\} where T\}} denotes a vector
of matrices with arbitrary element types.
In contrast, \cjl{Vector\{Matrix\{S\}\} where S} denotes a set of vectors where
elements are matrices with the same element type.
Thus, a vector of integer matrices \cjl{Vector\{Matrix\{Int\}\}} is a subtype
of the latter---existential---type, because \cjl{S} can be instantiated with
\cjl{Int}. But it is not a subtype of the former---invariant parametric---type
\cjl{Vector\{Matrix\{T\} where T\}}, because type arguments \cjl{Matrix\{Int\}}
and \cjl{Matrix\{T\} where T} are not equivalent.
\TODO{Explain the following better: Benjamin had questions.}
Note that because of the impredicativity, type arguments of invariant type
constructors such as \cjl{Vector} are arbitrarily complex. Thus, even though any
particular \cjl{Vector\{t\}} is a concrete type, checking subtyping for this
type requires a subtyping check for an arbitrary \cjl{t}.

Existential types serve at least two distinct purposes in the Julia language.
First, parametric types with existential parameters,
such as \[\text{\cjl{Vector\{Matrix\{T\} where T\}}},\]
are useful for representing heterogeneous data.
Second, top-level existential types, such as
\[\text{\cjl{Tuple\{T, Vector\{T\}\} where T}},\] represent
type signatures of parametric method definitions.
It may be surprising that Julia uses existential rather than universal types,
but recall that the primary purpose of types is to serve multiple dispatch.
In Julia, it is impossible to directly invoke a parametric method definition
and provide it with a type argument. Instead, the method is being dispatched to if
subtyping for the corresponding existential type succeeds. Then, in the body of
the method, the existential type is implicitly unpacked, with the witness type
being some valid instantiation induced by subtyping.
Consider the following code snippet as an example:
\begin{codeenvd}
\begin{julia}
f(v :: Vector{T}) where T = 
    Set{T}(v)

f([5, 7, 5]) # returns Set{Int} with 2 elements: 5, 7
\end{julia}
\end{codeenvd}
Because \cjl{[5, 7, 5]} is a \cjl{Vector\{Int\}} and
\cjl{Tuple\{Vector\{Int\}\}} is a subtype of the existential
\cjl{Tuple\{Vector\{T\}\} where T},
as witnessed by the instantiation of \cjl{T} with \cjl{Int},
the call \cjl{f([5, 7, 5])} dispatches to the method in line~1,
and \cjl{T} in the body of the method becomes \cjl{Int}.
However, when multiple instantiations of the variable are possible,
Julia sometimes gives up on assigning the witness type.
In the example below, subtyping succeeds for the call \cjl{g(true)},
because \cjl{Tuple\{Bool\}} is a subtype of \cjl{Tuple\{T\} where T>:Int}:
there are, in fact, multiple possible instantiations \cjl{t} of \cjl{T}
such that \cjl{Tuple\{Bool\} <: Tuple\{t\}},
e.g. \cjl{Any} or \cjl{Union\{Int, Bool\}}.
But rather than pick one instantiation, Julia throws an error:
\begin{codeenvd}
\begin{julia}
> g(x::T) where T>:Int = begin
    println(x)
    println(T)
  end

> g(true)
true
ERROR: UndefVarError: T not defined
\end{julia}
\end{codeenvd}
On the other hand, for the call \cjl{g(5)}, \cjl{T} is assigned the smallest
possible type, \cjl{Int}:
\begin{codeenvd}
\begin{julia}
> g(5)
5
Int
\end{julia}
\end{codeenvd}

Subtyping of existential types includes a special case, called 
the \tdef{diagonal rule}, which provides the support for
a generic programming pattern where method arguments are expected
to be of the same concrete type.
Consider the following method definition, which defines equality
\cjl{(==)} in terms of the built-in equality of bit representations \cjl{(===)}:
\begin{codeenvd}
\begin{julia}
==(x::T, y::T) where T<:Number = x === y
\end{julia}
\end{codeenvd}
If it were possible to instantiate \cjl{T} with an abstract type such as
\cjl{Integer}, the method could be called with a pair of a signed and unsigned
integer. This would be an incorrect implementation of equality, for the same bit
representation corresponds to different numbers when interpreted with and
without the sign.
To prevent such behavior, the diagonal rule states: if a type variable
appears in the type (1) only covariantly and (2) more than once,
it can be instantiated
only with concrete types.\footnote{A similar rule applies to static resolution
of method overloading in \CSharp. An example can be found on this page:
\href{https://fzn.fr/projects/lambdajulia/diagonalcsharp.pdf}{https://fzn.fr/projects/lambdajulia/diagonalcsharp.pdf}}
Thus, the type signature of \cjl{(==)} above,
\cjl{Tuple\{T, T\} where T<:Number}, represents a restricted existential type:
it is a union of tuples \cjl{Tuple\{t, t\}} where \cjl{t} is a concrete subtype
of \cjl{Number}. The same rule applies in line~3
of~\figref{fig:code:subtraction}: built-in integer subtraction \cjl{sub_int} is
guaranteed to be called only with primitive integers of the same concrete type.

\section{Specification of Julia Subtyping}\label{sec:julia-sub:lambda-julia}
%% ======================================================================

For Julia programmers, reasoning about the subtype relation is necessary
to understand and correctly use multiple dynamic dispatch.
However, the language documentation does not provide a specification
of subtyping: instead, subtyping is mentioned in multiple sections related to
type constructors and multiple dispatch.
Initially, an incomplete (and soon outdated) definition of subtyping existed 
only in~\cite{bib:bezanson:julia:2015}, with the actual implementation of 
subtyping ($\sim$3000 lines of heavily optimized C~code as of May 2023)
being the only reference point.

In this section, I present a fragment of the specification of Julia subtyping
from~\cite{bib:zappa-nardelli:julia-sub:oopsla:2018}.
In that work, my collaborators and I defined, implemented, and empirically
validated a subtype relation,
thus providing the first complete\footnote{The only omitted feature is the
\cjl{Vararg\{T,N\}} construct, which can be used as the last
parameter of a tuple to denote N trailing arguments of type \cjl{T}.}
specification of Julia subtyping.
Having reconstructed the subtype relation,
we were able to identify multiple issues such as
counterexamples to reflexivity and transitivity,
and suspected the undecidability of subtyping,
which was later proved by~\TODO{Ben's thesis}.
Most of the bugs we reported have been fixed by Julia developers.
Furthermore, the treatment of union types in the diagonal rule has changed
based on our proposal.
%\TODO{perhaps provide more details here}

The subtyping fragment is presented in~\figref{fig:jlsubex}. 
It includes only features relevant to the undecidability of subtyping, namely:
unions, tuples, invariant constructors, and existential types.
Following the paper, types are written as in the Julia language:
for example, existential types are represented with \cjl{where}.
``Plain bits'' values, nominal subtyping, 
subtyping of \cjl{Type\{t\}}, and the diagonal
rule\footnote{The treatment of union types in the diagonal rule has changed
since the paper was published, but the paper contains a discussion of the
issue.} are omitted, but they can be found
in~\cite{bib:zappa-nardelli:julia-sub:oopsla:2018}.

\begin{figure}
\footnotesize
\makebox[\textwidth][c]{
\begin{minipage}{\ruleswidth}
\[
  t\ ::=\ \anytyp 
    \Alt \uniontyp{\t_1, \ldots, \t_n}
    \Alt \tupletyp{\t_1, \ldots, \t_n}
    \Alt \cstrt{name}{\t_1, \ldots, \t_n}
    \Alt \wheret{\t}{l <: \T <: u}
    \Alt \T
\]
\begin{mathpar}
\\
\fbox{\ljsub{E}{t}{t}{E}}
\\

\inferrule[Top]
    {  }
    { E \vdash \t <: \anytyp \vdash E }

\inferrule[Refl]
    {  }
    { E \vdash \t <: \t \vdash E }

\inferrule[Tuple]
    { E \vdash \t_1 <: \t'_1 \vdash E_1 \\ \ldots \\ 
      E_{n-1} \vdash \t_n <: \t'_n \vdash E_n}
    { E \vdash \tupletyp{\t_1, \ldots, \t_n} <: 
      \tupletyp{\t'_1, \ldots, \t'_n} \vdash E_n }

\inferrule[Tuple\_Lift\_Union]
    { \t' = \mathit{lift\_union}(\tupletyp{\t_1, \ldots, \t_n}) \\
      E \vdash \t' <: \t \vdash E' }
    { E \vdash \tupletyp{\t_1, \ldots, \t_n} <: \t' \vdash E' }

\inferrule[Tuple\_Unlift\_Union]
    { \t' = \mathit{unlift\_union}(\uniontyp{\t_1, \ldots, \t_n}) \\
      E \vdash \t' <: \t \vdash E' }
    { E \vdash \t <: \uniontyp{\t_1, \ldots, \t_n} \vdash E' }

\inferrule[Union\_Left]
    { E \vdash \t_1 <: \t \vdash E_1 \\ \ldots \\ 
      E_{n-1} \vdash \t_n <: \t \vdash E_n}
    { E \vdash \uniontyp{\t_1, \ldots, \t_n} <: \t \vdash E_n }

\inferrule[Union\_Right]
    { \exists j.\ E \vdash \t <: \t_j \vdash E' }
    { E \vdash t <: \uniontyp{\t_1, \ldots, \t_n} \vdash E' }

\inferrule[App\_Inv]
    { E_0 = \mathit{add}(E, \text{Barrier}) \\ 
      \forall\, 0 < i \leq n. \  
      E_{i-1} \vdash \t_i <: \t'_i \vdash E'_i \ \wedge\  
      E'_i \vdash \t'_i <: \t_i \vdash E_i \\
    }
    { E \vdash \cstrt{name}{\t_1, \ldots, \t_n} <: 
      \cstrt{name}{\t'_1, \ldots, \t'_n} \vdash \mathit{del}(\text{Barrier}, E_n)}

\inferrule[L\_Intro]
    { \mathit{add}(^L \T_{l}^{u}, E) \vdash \t <: \t' \vdash E'}
    { E \vdash (\wheret{\t}{l <: \T <: u}) <: \t' \vdash \mathit{del}(\T, E') }

\inferrule[R\_Intro]
    { \mathit{add}(^R \T_{l}^{u}, E) \vdash \t <: \t' \vdash E' \\
      \mathit{consistent}(\T, E') }
    { E \vdash \t <: (\wheret{\t'}{l <: \T <: u}) \vdash \mathit{del}(\T, E') }

\inferrule[L\_Left]{
  \mathit{search}(\T, E) = {^L \T}_{l}^{u} \\
  E \vdash u <: \t \vdash E' }
  { E \vdash \T <: \t \vdash E' }

\inferrule[L\_Right]{
  \mathit{search}(\T, E) = {^L \T}_{l}^{u} \\
  E \vdash \t <: l \vdash E' }
  { E \vdash \t <: \T \vdash E' }
\\
\inferrule[R\_Left]{
  \mathit{search}(\T, E) = {^R \T}_{l}^{u} \\\\
  E \vdash l <: \t \vdash E' }
  { E \vdash \T <: \t \vdash \mathit{upd}({^R \T}_{l}^{t}, E') }

\inferrule[R\_Right]{
  \mathit{search}(\T, E) = {^R \T}_{l}^{u} \\
  (\mathit{is\_var}(\t) \wedge \mathit{search}(\t, E) = {^L \S}_{l'}^{u'}) 
    \implies \lnot \mathit{outside}(\T, \S, E) \\\\
  E \vdash \t <: u \vdash E' }
  { E \vdash \t <: \T \vdash \mathit{upd}({^R T}_{\uniontyp{l, \t}}^{u}, E') }

\inferrule[R\_L]{
  \mathit{search}(\T_1, E) = {^R \T_1}_{l_1}^{u_1} \\
  \mathit{search}(\T_2, E) = {^L \T_2}_{l_2}^{u_2} \\
  \mathit{outside}(\T_1, \T_2, E) \implies E \vdash u_2 <: l_2 \vdash E' \\
  E \vdash u_1 <: l_2 \vdash E''
}
    { E \vdash \T_1 <: \T_2 \vdash 
    \mathit{upd}(^R {\T_1}_{\uniontyp{\T_1, l_1}}^{u_1}, E') }
\end{mathpar}
\end{minipage}}
\caption{Julia subtyping (extract from
\cite{bib:zappa-nardelli:julia-sub:oopsla:2018})}
\label{fig:jlsubex}
\end{figure}

In~\figref{fig:jlsubex}, subtyping is defined in the form of a judgment
\[
  \ljsub{E}{t}{t'}{E'},
\]
which should be read as:
\emph{in the environment $E$, type $t$ is a subtype of~$t'$,
with updated constraints $E'$}.
$E$ is a type variable environment that contains two kinds of variables,
forall (also called left) and exist (also called right).
A variable \T introduced by an existential \emph{on the left} of the subtyping
judgment is recorded as $^L \T_l^u$, and a variable introduced
\emph{on the right} as $^L \T_l^u$; 
$l$ and $u$ are the lower-bound and upper-bound types of the variable.
Within the subtype judgment, left and right variables behave differently.
\begin{itemize}
  \item Left variables never change in the environment, and subtyping should
  hold with respect to their declared bounds.
  Thus, if a left \T appears on the
  left of the judgment, then the judgment can be satisfied
  only if the upper bound of \T is smaller than $t$:
  \[ ^L \T_l^u \vdash \T <: t \vdash ^L\! \T_l^u\ \ \text{ if }\ \ 
     ^L \T_l^u \vdash u <: t \vdash ^L\!\T_l^u. \]
  If \T appears on the right, then
  it is the lower bound of \T that must be a supertype of $t$:
  %
  \[ ^L \T_l^u \vdash t <: \T \vdash ^L\! \T_l^u \ \ \text{ if }\ \ 
     ^L \T_l^u \vdash t <: l \vdash ^L\!\T_l^u. \]
  This corresponds to the intuition that for a left-hand side existential type,
  subtyping should hold for all possible instantiations of the type variable.
  \item Right variables, on the other hand, may accrue subtype constraints
  in addition to their declared bounds;
  updated bounds are recorded in the output environment~$E'$.
  For example, if a right \T appears on the right of the judgment,
  its lower bound can become larger (but not larger than the upper bound):
  \[ ^R \T_{\uniontyp{}}^{\anytyp} \vdash \jlname{Int} <: \T \vdash 
     ^R\!\T_{\jlname{Int}}^{\anytyp}. \]
  If all the constraints
  are consistent, subtyping succeeds, which corresponds to the intuition that
  for a right-hand side existential type, subtyping holds
  if there exists a valid instantiation of the type variable.  
\end{itemize}
The following paragraphs provide examples and describe the structure of the
judgment in more detail, before focusing on the exact rules.

\TODO{Tuple and Inv}

\paragraph{Environment structure.}
The environment has a non-trivial structure.  First, an
environment $E$ is composed of two lists, denoted by
$E.curr$ and $E.past$.  The former, $E.curr$, is a
stack of variables currently in scope (growing on the right),
reflecting the order in which variables have been added to the scope.
In addition to variables, $E.curr$ records \emph{barriers}: tags pushed
to the environment whenever the subtype check encounters an invariant
constructor.  Barriers will be discussed later.
The second list, $E.past$,
keeps track of variables that are not any longer in scope.  Consider
the judgment:
\[
    \tupletyp{\wheret{\cstrt{\jlname{Ref}}{\S}}{\S <: \jlname{Int}}} \ <:\ 
    \wheret{\tupletyp{\cstrt{\jlname{Ref}}{\T}}}{\T}.
\]
In the derivation, the variable
\T is introduced before the variable \S, but \T's bounds refer to \S
in the judgment
\[ ^R \T_{\uniontyp{}}^{\anytyp}, ^L \S_{\uniontyp{}}^{\jlname{Int}} \vdash
   \cstrt{\jlname{Ref}}{\S} <: \cstrt{\jlname{Ref}}{\T} \vdash 
   ^R\!\T_S^S, ^L \S_{\uniontyp{}}^{\jlname{Int}}, \]
which appears in the derivation tree.
Discharged variables are thus stored in \(E.past\) and accessed whenever
required.  The subtyping rules guarantee that it is never necessary to
update the bounds of a no-longer-in-scope variable.  Relying on a
separate \(E.past\) environment avoids confusion when rules must
determine precisely the scope of each variable.
%, as motivated in the next paragraph.

Variables can be subject to unsatisfiable
constraints.  For instance, the subtype relation
\[
    \tupletyp{\anytyp, \reftyp{\inttyp}} \nless: 
    \wheret{\wheret{\tupletyp{\S, \reftyp{\T}}}{\S<:\T}}{\T}
\]
does not hold because the type variables are subject to the three
unsatisfiable constraints below, for \cjl{Any} is not a subtype of \cjl{Int}:
\[
\anytyp <: \S \qquad\quad \S <: \T \qquad\quad  \inttyp <: \T <: \inttyp.
\]
The subtyping algorithm records these constraints in the environment
as \( ^R \T_{\inttyp}^{\inttyp}, ^R\!\S_{\anytyp}^{\T} \), and whenever
a right-variable is discharged, it checks that its lower bound is a subtype of
its upper bound.  In the example above, the derivation is invalidated
by the failure of the consistency check for \S:
%
\[ ^R \T_{\inttyp}^{\inttyp}, ^R\!\S_{\anytyp}^{\T} \vdash \anytyp \nless: \T. \]

\paragraph{From forall/exist to exist/forall.}  In some cases,
enforcing the correct ordering of type variable quantifications
requires extra care.  Consider the judgment:
\[ \vectyp{\wheret{\vectyp{\T}}{\T}} \nless: 
  \wheret{\vectyp{\vectyp{\S}}}{\S}. \]
The type on the left denotes the set of all the vectors of
vectors of elements of some type; the type on the right
requires a common type for all the inner
vectors.  For instance, the value
\cjl{[ [1,2],["a","b"] ]} belongs to the first, but
not the second, type.
If the subtyping algorithm simply introduced variables \S and \T into
the environment, the following judgments would succeed, because
for all instances of \(T\) there is a matching type for \(S\):
\[
  ^R \S_{\uniontyp{}}^{\anytyp}, ^L\!\T_{\uniontyp{}}^{\anytyp} \vdash \T <: \S
  \qquad\text{ and }\qquad
  ^R \S_{\uniontyp{}}^{\anytyp}, ^L\!T_{\uniontyp{}}^{\anytyp} \vdash \S <: \T
\]
However, we must instead find an instance of \(\S\) such that 
the judgment holds forall \T: perhaps surprisingly, the outer invariant
construct \(\jlname{Vector}\) forces the inversion of the order of quantifications.
Instead of a forall/exist query we must solve an \emph{exist/forall} one.
To correctly account for inversion in the order of quantifications,
derivations must keep track of the relative ordering of
variable introductions and invariant constructors.  For this, the
environment \(E.curr\) is kept ordered, and
\emph{barrier} tags are pushed into \(E.curr\) whenever the derivation goes through
an invariant constructor.

We say that a variable \(\S\) is \emph{outside} a variable
\(\T\) in an environment \(E\) if \(\S\) precedes \(\T\)
in \(E.curr\) and they are separated by a barrier tag in~\(E.curr\).  

In our running example, the first check thus becomes:
\[ ^R \S_{\uniontyp{}}^{\anytyp}, \Barrier, ^L\!\T_{\uniontyp{}}^{\anytyp} 
\vdash \T <: \S. \]
\noindent The environment correctly identifies the variable \S
as outside \T, and the judgment should thus be interpreted as
\emph{there exists an instance of \S such that, forall instances of
\T, \( \T <: \S \) holds}.  The variable \S must thus be
compared with the upper bound of \T, deriving \anytyp as the lower bound:
\[ 
  ^R \S_{\uniontyp{}}^{\anytyp}, \Barrier, ^L\!\T_{\uniontyp{}}^{\anytyp} 
  \vdash \anytyp <: \S \vdash ^R \S_{\anytyp}^{\anytyp}.
\]
Again, given \S outside \T, the right-to-left check must now prove
\[ ^R \S_{\anytyp}^{\anytyp}, \Barrier, ^L\!T_{\uniontyp{}}^{\anytyp} 
\vdash \S <: \T, \]
that is, it must conclude that there exists an instance of \S
such that, forall instances of \T, \(\S <: \T\) holds.  In
other terms, the variable \S must be a subtype of the lower
bound of \T.  This fails, as expected.

Note that whenever the forall variable is constrained tightly and
quantifies over only one type, the exist/forall quantification can still
correctly succeed, as in the valid judgment below:
\[ 
  \reftyp{\wheret{\reftyp{\inttyp{<:}\T{<:}\inttyp}}{\T}} <: 
  \wheret{\reftyp{\reftyp{\S}}}{\S}.
\]


\TODO{Lambda-Julia}

\section{Undecidability of Julia Subtyping}\label{sec:julia-sub:undec}
%% ======================================================================

\begin{figure}
\[
\begin{array}{rcl}
  \interp{\mathit{Top}} &=& \text{\cjl{Union\{\}}}\\
  \interp{\alpha} &=& \alpha\\
  \interp{\forall\alpha\leq\ty.\ty'} &=&
    \text{\cjl{Tuple\{Ref\{}}\alpha\text{\cjl{\}, }}
    \interp{\ty'}\text{\cjl{\} where\ }}\alpha\text{\cjl{\ >:\ }}\interp{\ty}\\
\end{array}
\]
\caption{Encoding of \FSubN types in Julia}\label{fig:FSub-encoding}
\end{figure}

It is not unusual for a statically typed programming language 
to have undecidable subtyping,
as witnessed by Java and Scala~\cite{bib:grigore:java-undec:2017,bib:hu:dot-undec:2020}.
In practice, the undecidability means that the
compiler might not terminate on some programs. Although undesirable,
such property can be acceptable if it manifests rarely and
allows for an expressive type system.

In a dynamically typed Julia, however, subtyping is used at run time---for
dispatch resolution. Even on rare occasions, consequences of
undecidability at run time are of greater concern than at compile time.
That is why the decidability of subtyping was one of the explicit goals
of the original design of the Julia language~\cite{bib:bezanson:julia:2015}.
To this end, Julia disallowed several features that were known to cause
undecidability, such as recursive constraints on type variables and
circularities in the inheritance hierarchy~\cite{bib:tate:taming-wildcards:2011}.

Despite the intentional simplifications in the type language,
Julia subtyping is in fact \emph{undecidable}.
As shown in~\TODO{Ben's thesis}, Julia can encode system
\FSubN, which is known to be undecidable~\cite{bib:pierce:bound-sub-undec:1992}.
\figref{fig:FSub-encoding} shows the encoding\footnote{Arrow %of \FSubN types
type is dropped as irrelevant to the undecidability result.},
with $\ty_1 \leq \ty_2$ in \FSubN defined as
$\interp{\ty_2} <: \interp{\ty_1}$ in Julia.
In practice, the undecidability %of Julia subtyping 
manifests itself with a \cjl{StackOverflowError}.
The reason is that internally, Julia relies on a dedicated stack
to resolve subtyping
and terminates the program when the stack reaches a certain limit.
%Thus, in practice, subtyping checks that showcase undecidability, such as
%the Ghelli example, often manifest with a \cjl{StackOverflowError}
%rather than non-termination.

Although the undecidability of a particular subtyping algorithm
does not necessarily mean that decidable subtyping for the same
language of types does not exist, I \emph{conjecture} that
\begin{quotation}\emph{
  there is no decidable subtype relation for Julia's language of types
  that would agree with the intended subtyping behavior
  described in \secref{sec:julia-sub:overview}.
}\end{quotation}
The problem lies in the interaction of
impredicative existential types, invariant constructors, and unions,
as discussed in more detail below.
In the discussion, I intentionally depart from the notation of the subtyping
specification presented in the previous section \ref{sec:julia-sub:lambda-julia},
as I am interested in the existence of some other, decidable subtype relation.
\TODO{fix if this is not precise}

First, recall that parametric datatypes are invariant, meaning that
types such as \cjl{Ref\{t\}} and \cjl{Ref\{t'\}} are subtypes
only if their type arguments \cjl{t} and \cjl{t'} are equivalent.
The equivalence of types can be expressed via subtyping:
$t$ and $t'$ are equivalent
if both $t <: t'$ and $t' <: t$ hold.
To check for equivalence, one can either rely on subtyping directly
or use a separate relation $t \approx t'$ such that 
$t \approx t' \ \implies\ t <: t'\ \land\ t' <: t$.

Next, recall that a union-all type \cjl{t where l<:X<:u} is meant to represent
a union of types $t[t_X/X]$ for all possible valid instantiations
$l <: t_X <: u$ of the type variable $X$.
Thus, whenever subtyping is checked for some 
\cjl{t' <: (t where l<:X<:u)}, the subtyping algorithm needs to check that
there exists a valid instantiation of $X$.
I will refer to such variable...

and it is the ``flipped'' subtyping check \subty{}{t'}{t} 
An alternative approach would be to use a separate equivalence relation.


\TODO{consider the example from the proposal}
