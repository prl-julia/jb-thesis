\chapter{Related work}\label{chap:5}

Subtyping is typically associated with object-oriented programming languages and
static type systems. As a part of a type system, subtyping allows
an expression of a more specific type (subtype) to be used in place
where an expression of a more general type (supertype) is expected,
enabling more benign programs to be typable.
Subtyping can also be used at run time
in both statically and dynamically typed languages to perform
type tests, casts, and dynamic dispatch.

\section{Decidability}
%% ======================================================================

Although decidability is desirable for a static type system and its
subtyping relation, establishing decidability can be challenging.
For example, the \emph{un}decidability of checking subtyping for Java generics
was established only fairly recently by~\citet{grigore:java-undec:2017},
and the previously suspected undecidability of subtyping and type checking 
the core calculus of Scala 3,
DOT (Dependent Object Calculus)~\cite{amin:dot:2016},
was proven by~\citet{hu:dot-undec:2020}.

Typically, undecidability is shown by a reduction from a known undecidable
problem. For example, the halting problem for Turing machines was used
to prove the undecidability of Java generics~\cite{grigore:java-undec:2017}
% the culprit is recursive inheritance in Java generics
as well as System \FSub~\cite{pierce:bound-sub-undec:1992}.
%There, rebounding of type variables in the rule for subtyping universal types
%leads to the growth of type variable context.
\FSub~\cite{cardelli:fsub:1991} is a language with bounded universal types,
and proofs by reduction from \FSub are commonly used to establish
undecidability in languages with some form of bounded quantification.
For instance, the undecidability of DOT~\cite{hu:dot-undec:2020} was shown
by reducing a variant of \FSub to \DSub, a restriction of DOT featuring type
members and path-dependent types. A similar approach was used
by~\citet{mackay:path-dep-dec:2020} for \WyvCore, another simplification of
DOT featuring path-dependent and recursive types.
In the case of Julia, the undecidability of subtyping also follows from its
power to encode a variant of \FSub,
as discussed in~\secref{sec:2:undecidable}.
%In the context of languages with nominal inheritance and variance,
%\citet{kennedy:nom-sub-var-dec:2007} showed the undecidability of subtyping
%by a reduction from the Post correspondence problem.

Practically, undecidability of a static type system manifests itself with
the compiler not terminating or crashing. In some cases,
benefits of having a more expressive type system might outweigh the cost of
undecidability: if the undecidability arises only in rare, contrived cases,
being able to successfully type check more benign programs
%at the cost of rare compiler crashes
might be preferable to reliably rejecting those
programs with a decidable but less expressive type system.

When subtyping is used at run time, the cost of undecidability is higher
because a crash or non-termination could happen during program execution
rather than compilation.
In mainstream programming languages that require run-time subtyping checks,
run-time types are often more restrictive than static ones,
which simplifies the corresponding subtyping problem.
For example, in the .NET intermediate language,
the decidability of subtyping was shown for ground types,
which are used at run time~\cite{kennedy:nom-sub-var-dec:2007}\footnote{Due
to the lack of documentation, it is not clear whether subtyping between ground
types is still decidable in \CSharp as of 2022.}.
In the case of Java generics where static subtyping is undecidable,
the type erasure mechanism allows for decidable run-time subtyping.
In Julia, however, it is the \emph{run-time} subtyping that is undecidable,
yet subtyping is heavily used by the dynamic semantics for resolving dispatch.

Identifying decidable fragments of undecidable type systems
remains an important challenge.
In some cases, it might be possible to recover
decidability by restricting the system in a way that does not affect most
practical programs. For example, the material-shape separation for Java
generics~\cite{greenman:f-bound-material-shape:2014}
enables decidability of subtyping by limiting F-bounded polymorphism %~\cite{canning:f-bound:1989}
(i.e., recursive constraints on type variables)
to the subset of types, called shapes, that are used exclusively as constraints;
this separation appears to be in agreement with an industry-wide practice.
\citet{mackay:path-dep-dec:2020} extended the material-shape separation
to the context of path-dependent and recursive types. %, with additional
%restrictions to ensure decidability.
Earlier, \citet{kennedy:nom-sub-var-dec:2007} identified three decidable
fragments of undecidable subtyping in the context of nominal inheritance
and variance without F-bounded polymorphism: the fragments can be obtained by
restricting either contravariance, or expansive class tables,
or multiple instantiation inheritance.
Aiming for decidable subtyping, Julia designers deliberately restricted
the language from F-bounded polymorphism, contravariant constructors,
and multiple inheritance.
Based on those restrictions, \citet{bezanson:julia:2015} conjectured
the decidability but pointed out that
the combination of invariant constructors
and contravariance in lower bounds of existential types
is akin to one of the undecidability ingredients of \FSub.
Indeed, this combination turned out to be powerful enough to encode \FSub.

A number of decidable subtyping relations adopt subtyping rules
inspired by a decidable variant of \FSub
called Kernel \FSub~\cite{cardelli:types-poly:1985}.

One of the decidable variants of
subtyping they proposed, \WyvFix, uses two different contexts for
type variables from the left- and right-hand sides of a subtyping relation.

%to achieve decidability, they propose to either restrict the use of
%recursive types in materials or to remove environment narrowing,
%where a recursive subtyping call uses an environment with more precise
%type information.


\cite{hu:dot-undec:2020,mackay:bound-poly-sub-dec:2020,kennedy:nom-sub-var-dec:2007}.
\TODO{D<: and two contexts}

\TODO{Talk about issues that cause undecidability and F-bounded polymorphism.}

\TODO{Semantic subtyping and Java wildcards (several paragraphs).}

Subtyping and decidability of subtyping are clearly a problem in various languages,
but we will focus on several related subsets.

Decidable and undecidable systems. Subtyping in PL..

\section{Semantic subtyping}
%% ======================================================================

In Julia, subtyping of union and tuple types (maybe also invariant ones?) build
on top of \TODO{Voulon} and has similarities to XDuce/CDuce.
There is a large body of work on semantic subtyping, which extends it to
function and polymorphic types. However, such systems do not deal with
impredicative types.
For example, \citet{frih:sem-sub:2008} describe a framework for defining semantic
subtyping without building a model of the entire language, and then define
decidable subtyping and type checking for a language with dynamic dispatch,
unions, functions, and negation types.\TODO{clean up the description}

In the semantic subtyping approach, types are interpreted as subsets of the
model of the programming

\TODO{\cite{hosoya:xduce:2003, bezanken:cduce:2003}}
