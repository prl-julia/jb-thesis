\chapter{Julia Subtyping}%
\label{chap:julia-sub}

\TODO{Intro, reference lambda-julia}

\section{Overview}\label{sec:julia-sub:overview}
%% ======================================================================

Subtyping in Julia largely follows the combination of
\tdef{nominal subtyping} for user-defined nominal types and
\tdef{semantic subtyping} for covariant tuple and union types.
For example, using types from \figref{fig:code:user-def-types}, we note that
\cjl{Int128} is a subtype of \cjl{Signed}, and, transitively, of \cjl{Integer};
\cjl{BitSet} is a subtype of \cjl{AbstractSet\{Int\}}.
%but not \cjl{AbstractSet\{String\}}.
A~union type \cjl{Union\{t1, t2, ...\}} describes a set-theoretic union of
types \cjl{t1}, \cjl{t2}, \cjl{...}; for example, \cjl{Int} is a subtype of
\cjl{Union\{Signed, String\}}, and \cjl{Union\{t1, t2, ...\} <: t} if all
components \cjl{t1 <: t, t2 <: t, ...}.
Tuples in Julia are immutable, and tuple types are covariant:
\cjl{Tuple\{t1, t2, ...\}} is a subtype of \cjl{Tuple\{t1', t2'...\}} if
their corresponding components are subtypes, i.e., \cjl{t1 <: t1', t2 <: t2', ...}.
Following semantic subtyping, tuple types distribute over unions,
so types \cjl{Tuple\{Union\{Int,String\}\}} and
\cjl{Union\{Tuple\{Int\},Tuple\{String\}\}} are equivalent.

User-defined parametric datatypes are invariant in the type parameter
regardless of whether the datatype is
mutable or immutable, meaning that \cjl{Name\{t1, t2, ...\}} is a subtype of 
\cjl{Name\{t1', t2', ...\}} only if the corresponding type arguments are equivalent,
i.e., \cjl{t1 <:> t1'}, \cjl{t2 <:> t2', ...}.
Thus, the immutable invariant datatype \cjl{Rational\{Int\}} is \emph{not}
a subtype of \cjl{Rational\{Signed\}}.
%while the covariant tuple \cjl{Tuple\{Int\} <: Tuple\{Signed\}}.

Abstract union-all types \cjl{t where l<:T<:u} are better known
in the literature as \tdef{bounded existential types}, which also model
Java wildcards~\cite{bib:torgersen:wildcards:2004}\footnote{In Julia syntax, 
a Java wildcard type
\cjl{Foo<?>} can be written as \cjl{Foo\{T\} where T}.}.
In what follows, we will call types \cjl{t where l<:T<:u} existential types;
if lower (upper) bound on the type variable is omitted, it defaults to the
bottom type \cjl{Union\{\}} (top type \cjl{Any}).
Intuitively, an existential type denotes a union of \cjl{t[t'/T]} for all
instantiations of the type variable \cjl{T} such that \cjl{l <: t' <: u}.
Similarly to subtyping of finite union types, the intent is that:
\begin{itemize}
  \item \cjl{(t where l<:T<:u) <: t2} if \emph{for all} valid instantiations
    \cjl{l<:t'<:u}, it holds that \cjl{t[t'/T] <: t2}, and
  \item \cjl{t1 <: (t where l<:T<:u)} if \emph{there exists} at least one 
    \cjl{l<:t'<:u} such that \cjl{t1 <: t[t'/T]}.
\end{itemize}
For example, \cjl{Vector\{Int\}} is a subtype of \cjl{Vector\{T\} where
T<:Integer} because \cjl{T} can be instantiated with \cjl{Int},
and \cjl{Vector\{T\} where T<:Integer} is a subtype of
\cjl{Vector\{S\} where S} because for all valid instantiations \cjl{t'} of~\cjl{T},
type variable \cjl{S} can be instantiated with the same type \cjl{t'}.
Just like unions, existential types distribute over tuples:
for example, types \cjl{Tuple\{Vector\{T\} where T\}}
and \cjl{Tuple\{Vector\{T\}\} where T} are equivalent.

Existential types in Julia are \emph{impredicative}:
existential quantifiers can appear anywhere in a type,
and type variables can be instantiated with arbitrary existential types.
For example, type \cjl{Vector\{Matrix\{T\} where T\}} denotes a vector
of matrices with arbitrary element types.
In contrast, \cjl{Vector\{Matrix\{S\}\} where S} denotes a set of vectors where
elements are matrices with the same element type.
Thus, a vector of integer matrices \cjl{Vector\{Matrix\{Int\}\}} is a subtype
of the latter---existential---type, because \cjl{S} can be instantiated with
\cjl{Int}. But it is not a subtype of the former---invariant parametric---type
\cjl{Vector\{Matrix\{T\} where T\}}, because type arguments \cjl{Matrix\{Int\}}
and \cjl{Matrix\{T\} where T} are not equivalent.
\TODO{Explain the following better: Benjamin had questions.}
Note that because of the impredicativity, type arguments of invariant type
constructors such as \cjl{Vector} are arbitrarily complex. Thus, even though any
particular \cjl{Vector\{t\}} is a concrete type, checking subtyping for this
type requires a subtyping check for an arbitrary \cjl{t}.

Existential types serve at least two distinct purposes in the Julia language.
First, parametric types with existential parameters,
such as \[\text{\cjl{Vector\{Matrix\{T\} where T\}}},\]
are useful for representing heterogeneous data.
Second, top-level existential types, such as
\[\text{\cjl{Tuple\{T, Vector\{T\}\} where T}},\] represent
type signatures of parametric method definitions.
It may be surprising that Julia uses existential rather than universal types,
but recall that the primary purpose of types is to serve multiple dispatch.
In Julia, it is impossible to directly invoke a parametric method definition
and provide it with a type argument. Instead, the method is being dispatched to if
subtyping for the corresponding existential type succeeds. Then, in the body of
the method, the existential type is implicitly unpacked, with the witness type
being some valid instantiation induced by subtyping.
Consider the following code snippet as an example:
\begin{codeenvd}
\begin{julia}
f(v :: Vector{T}) where T = 
    Set{T}(v)

f([5, 7, 5]) # returns Set{Int} with 2 elements: 5, 7
\end{julia}
\end{codeenvd}
Because \cjl{[5, 7, 5]} is a \cjl{Vector\{Int\}} and
\cjl{Tuple\{Vector\{Int\}\}} is a subtype of the existential
\cjl{Tuple\{Vector\{T\}\} where T},
as witnessed by the instantiation of \cjl{T} with \cjl{Int},
the call \cjl{f([5, 7, 5])} dispatches to the method in line~1,
and \cjl{T} in the body of the method becomes \cjl{Int}.
However, when multiple instantiations of the variable are possible,
Julia sometimes gives up on assigning the witness type.
In the example below, subtyping succeeds for the call \cjl{g(true)},
because \cjl{Tuple\{Bool\}} is a subtype of \cjl{Tuple\{T\} where T>:Int}:
there are, in fact, multiple possible instantiations \cjl{t} of \cjl{T}
such that \cjl{Tuple\{Bool\} <: Tuple\{t\}},
e.g. \cjl{Any} or \cjl{Union\{Int, Bool\}}.
But rather than pick one instantiation, Julia throws an error:
\begin{codeenvd}
\begin{julia}
> g(x::T) where T>:Int = begin
    println(x)
    println(T)
  end

> g(true)
true
ERROR: UndefVarError: T not defined
\end{julia}
\end{codeenvd}
On the other hand, for the call \cjl{g(5)}, \cjl{T} is assigned the smallest
possible type, \cjl{Int}:
\begin{codeenvd}
\begin{julia}
> g(5)
5
Int
\end{julia}
\end{codeenvd}

Subtyping of existential types includes a special case, called 
the \tdef{diagonal rule}, which provides the support for
a generic programming pattern where method arguments are expected
to be of the same concrete type.
Consider the following method definition, which defines equality
\cjl{(==)} in terms of the built-in equality of bit representations \cjl{(===)}:
\begin{codeenvd}
\begin{julia}
==(x::T, y::T) where T<:Number = x === y
\end{julia}
\end{codeenvd}
If it were possible to instantiate \cjl{T} with an abstract type such as
\cjl{Integer}, the method could be called with a pair of a signed and unsigned
integer. This would be an incorrect implementation of equality, for the same bit
representation corresponds to different numbers when interpreted with and
without the sign.
To prevent such behavior, the diagonal rule states: if a type variable
appears in the type (1) only covariantly and (2) more than once,
it can be instantiated
only with concrete types.\footnote{A similar rule applies to static resolution
of method overloading in \CSharp. An example can be found on this page:
\href{https://fzn.fr/projects/lambdajulia/diagonalcsharp.pdf}{https://fzn.fr/projects/lambdajulia/diagonalcsharp.pdf}}
Thus, the type signature of \cjl{(==)} above,
\cjl{Tuple\{T, T\} where T<:Number}, represents a restricted existential type:
it is a union of tuples \cjl{Tuple\{t, t\}} where \cjl{t} is a concrete subtype
of \cjl{Number}. The same rule applies in line~3
of~\figref{fig:code:subtraction}: built-in integer subtraction \cjl{sub_int} is
guaranteed to be called only with primitive integers of the same concrete type.

\section{Specification of Julia Subtyping}\label{sec:julia-sub:lambda-julia}
%% ======================================================================

For Julia programmers, reasoning about the subtype relation is necessary
to understand and correctly use multiple dynamic dispatch.
However, the language documentation does not provide a specification
of subtyping: instead, subtyping is mentioned in multiple sections related to
type constructors and multiple dispatch.
Initially, an incomplete (and soon outdated) definition of subtyping existed 
only in~\cite{bib:bezanson:julia:2015}, with the actual implementation of 
subtyping ($\sim$3000 lines of heavily optimized C~code as of May 2023)
being the only reference point.

In this section, I present a fragment of the specification of Julia subtyping
from~\cite{bib:zappa-nardelli:julia-sub:oopsla:2018}.
In that work, my collaborators and I defined, implemented, and empirically
validated a subtype relation,
thus providing the first complete\footnote{The only omitted feature is the
\cjl{Vararg\{T,N\}} construct, which can be used as the last
parameter of a tuple to denote N trailing arguments of type \cjl{T}.}
specification of Julia subtyping.
Having reconstructed the subtype relation,
we were able to identify multiple issues such as
counterexamples to reflexivity and transitivity,
and suspected the undecidability of subtyping,
which was later proved by~\TODO{Ben's thesis}.
Most of the bugs we reported have been fixed by Julia developers.
Furthermore, the treatment of union types in the diagonal rule has changed
based on our proposal.
%\TODO{perhaps provide more details about bugs and the diagonal rule here}

The subtyping fragment is presented in~\figref{fig:jlsubex}. 
It includes features relevant to the undecidability of subtyping, namely:
unions, tuples, invariant constructors, and existential types.
Following the paper, types are written as in the Julia language:
for example, existential types are represented with \cjl{where}.
``Plain bits'' values, nominal subtyping, 
subtyping of \cjl{Type\{t\}}, and the diagonal
rule\footnote{The treatment of union types in the diagonal rule has changed
since the paper was published, but the paper contains discusses the issue.}
are omitted, but they can be found
in~\cite{bib:zappa-nardelli:julia-sub:oopsla:2018}.

\begin{figure}
\footnotesize
\makebox[\textwidth][c]{
\begin{minipage}{\ruleswidth}
\[
  t\ ::=\ \anytyp 
    \Alt \uniontyp{\t_1, \ldots, \t_n}
    \Alt \tupletyp{\t_1, \ldots, \t_n}
    \Alt \cstrt{name}{\t_1, \ldots, \t_n}
    \Alt \wheret{\t}{l <: \T <: u}
    \Alt \T
\]
\begin{mathpar}
\\
\fbox{\ljsub{E}{t}{t}{E}}
\\

\inferrule[Top]
    {  }
    { E \vdash \t <: \anytyp \vdash E }

\inferrule[Refl]
    {  }
    { E \vdash \T <: \T \vdash E }

\inferrule[Tuple]
    { E \vdash \t_1 <: \t'_1 \vdash E_1 \\ \ldots \\ 
      E_{n-1} \vdash \t_n <: \t'_n \vdash E_n}
    { E \vdash \tupletyp{\t_1, \ldots, \t_n} <: 
      \tupletyp{\t'_1, \ldots, \t'_n} \vdash E_n }

\inferrule[Tuple\_Lift\_Union]
    { \t' = \mathit{lift\_union}(\tupletyp{\t_1, \ldots, \t_n}) \\
      E \vdash \t' <: \t \vdash E' }
    { E \vdash \tupletyp{\t_1, \ldots, \t_n} <: \t' \vdash E' }

\inferrule[Tuple\_Unlift\_Union]
    { \t' = \mathit{unlift\_union}(\uniontyp{\t_1, \ldots, \t_n}) \\
      E \vdash \t' <: \t \vdash E' }
    { E \vdash \t <: \uniontyp{\t_1, \ldots, \t_n} \vdash E' }

\inferrule[Union\_Left]
    { E \vdash \t_1 <: \t \vdash E_1 \\ \ldots \\ 
      E_{n-1} \vdash \t_n <: \t \vdash E_n}
    { E \vdash \uniontyp{\t_1, \ldots, \t_n} <: \t \vdash E_n }

\inferrule[Union\_Right]
    { \exists j.\ E \vdash \t <: \t_j \vdash E' }
    { E \vdash t <: \uniontyp{\t_1, \ldots, \t_n} \vdash E' }

\inferrule[App\_Inv]
    { E_0 = \mathit{add}(E, \text{Barrier}) \\ 
      \forall\, 0 < i \leq n. \  
      E_{i-1} \vdash \t_i <: \t'_i \vdash E'_i \ \wedge\  
      E'_i \vdash \t'_i <: \t_i \vdash E_i \\
    }
    { E \vdash \cstrt{name}{\t_1, \ldots, \t_n} <: 
      \cstrt{name}{\t'_1, \ldots, \t'_n} \vdash \mathit{del}(\text{Barrier}, E_n)}

\inferrule[L\_Intro]
    { \mathit{add}(^L \T_{l}^{u}, E) \vdash \t <: \t' \vdash E'}
    { E \vdash (\wheret{\t}{l <: \T <: u}) <: \t' \vdash \mathit{del}(\T, E') }

\inferrule[R\_Intro]
    { \mathit{add}(^R \T_{l}^{u}, E) \vdash \t <: \t' \vdash E' \\
      \mathit{consistent}(\T, E') }
    { E \vdash \t <: (\wheret{\t'}{l <: \T <: u}) \vdash \mathit{del}(\T, E') }

\inferrule[L\_Left]{
  \mathit{search}(\T, E) = {^L \T}_{l}^{u} \\
  E \vdash u <: \t \vdash E' }
  { E \vdash \T <: \t \vdash E' }

\inferrule[L\_Right]{
  \mathit{search}(\T, E) = {^L \T}_{l}^{u} \\
  E \vdash \t <: l \vdash E' }
  { E \vdash \t <: \T \vdash E' }
\\
\inferrule[R\_Left]{
  \mathit{search}(\T, E) = {^R \T}_{l}^{u} \\\\
  E \vdash l <: \t \vdash E' }
  { E \vdash \T <: \t \vdash \mathit{upd}({^R \T}_{l}^{t}, E') }

\inferrule[R\_Right]{
  \mathit{search}(\T, E) = {^R \T}_{l}^{u} \\
  (\mathit{is\_var}(\t) \wedge \mathit{search}(\t, E) = {^L \S}_{l'}^{u'}) 
    \implies \lnot \mathit{outside}(\T, \S, E) \\\\
  E \vdash \t <: u \vdash E' }
  { E \vdash \t <: \T \vdash \mathit{upd}({^R T}_{\uniontyp{l, \t}}^{u}, E') }

\inferrule[R\_L]{
  \mathit{search}(\T_1, E) = {^R \T_1}_{l_1}^{u_1} \\
  \mathit{search}(\T_2, E) = {^L \T_2}_{l_2}^{u_2} \\
  \mathit{outside}(\T_1, \T_2, E) \implies E \vdash u_2 <: l_2 \vdash E' \\
  E \vdash u_1 <: l_2 \vdash E''
}
    { E \vdash \T_1 <: \T_2 \vdash 
    \mathit{upd}(^R {\T_1}_{\uniontyp{\T_1, l_1}}^{u_1}, E') }
\end{mathpar}
\end{minipage}}
\caption{Julia subtyping (excerpt from
\cite{bib:zappa-nardelli:julia-sub:oopsla:2018})}
\label{fig:jlsubex}
\end{figure}

In~\figref{fig:jlsubex}, subtyping is defined in the form of a judgment
\[
  \ljsub{E}{t}{t'}{E'},
\]
which should be read as:
\emph{in the environment $E$, type $t$ is a subtype of~$t'$,
with updated constraints $E'$}.
$E$ is a type variable environment that contains two kinds of variables,
forall (also called left, introduced by existential types on the left
and recorded as $^L \T$) and exist (also called right, introduced by 
existential types on the right and recorded as $^R \T$).
Variables are recorded with their declared lower and upper bounds $l$ and $u$
as $\T_l^u$; bounds on exist (right) variables can get tighter during subtype
checking, which is reflected in the updated environment $E'$.
For example, consider the following judgment:
\[ 
  \tupletyp{\inttyp} <: \wheret{\tupletyp{\T}}{\uniontyp{}{<:}\T{<:}\anytyp}.
\]
First, the right variable \T is introduced into the environment with its
declared bounds $\uniontyp{}$ and \anytyp:
\[ 
  ^R \T_{\uniontyp{}}^{\anytyp} \vdash \tupletyp{\inttyp} <: \tupletyp{\T} \vdash\ ?
\]
Next, since tuples are covariant, it should be the case that \inttyp is
a subtype of \T.
Recall the intuition that for existential types on the right,
subtyping holds if there exists a valid instantiation of the variable
that would satisfy the judgment.
In the example, subtyping $\inttyp <: \T$ holds if the variable \T is
instantiated with a type that is a supertype of \inttyp. Therefore, this very
constraint is recorded in an updated environment as $^R \T_{\inttyp}^{\anytyp}$
(note the larger lower bound):
\[ 
  ^R \T_{\uniontyp{}}^{\anytyp} \vdash \inttyp <: \T 
  \vdash ^R\!\T_{\inttyp}^{\anytyp},
\]
and the new environment is propagated to the tuples:
\[ 
  ^R \T_{\uniontyp{}}^{\anytyp} \vdash \tupletyp{\inttyp} <: \tupletyp{\T}
  \vdash ^R\!\T_{\inttyp}^{\anytyp}.
\]

With the exception of \RLJ{Tuple\_Lift\_Union} and \RLJ{Tuple\_Unlift\_Union},
which are discussed later,
the rules for subtyping tuples, unions, and invariant constructors are
mostly straightforward.
The rule~\RLJ{Tuple} checks covariant subtyping of the tuple elements.
The rules~\RLJ{Union\_Left} and~\RLJ{Union\_Right}
implement the forall and exist semantics for union types on the left
and on the right of the subtyping judgment;
furthermore, the rule \RLJ{Union\_Left} allows for
deriving that \(\uniontyp{}\) is a subtype of all
types, because its hypothesis is trivially validated by the forall
quantification over an empty set.
In the rule \RLJ{App\_Inv} for invariant constructors,
the equality of corresponding type arguments $\t_i$ and $\t'_i$ is
ensured by checking both $\t_i <: \t'_i$ and $\t'_i <: \t_i$,
referred to as left-to-right and right-to-left checks, respectively;
the \Barrier construct is discussed later.
%Note that because of such right-to-left checks, type variables introduced 
%on one side of the judgment can appear on the opposite side.

Because the same right variable can appear in multiple positions, environment
updates $E'_i$ need to be propagated across all the elements of
a tuple/union/invariant constructor.
For instance, consider the following judgment:
\[ 
  ^R \T_{\uniontyp{}}^{\anytyp} \vdash 
  \tupletyp{\anytyp, \reftyp{\inttyp}} \nless: \tupletyp{\T, \reftyp{\T}}.
\]
After the first recursive call to subtyping,
\[ 
  ^R \T_{\uniontyp{}}^{\anytyp} \vdash \anytyp <: \T 
  \vdash ^R\!\T_{\anytyp}^{\anytyp},
\]
the variable \T is know to be a supertype of \anytyp.
Thus, subtyping between $\reftyp{\inttyp}$ and $\reftyp{\T}$ is invoked
in the updated environment:
\[ 
  ^R \T_{\anytyp}^{\anytyp} \vdash 
  \reftyp{\inttyp} \nless: \reftyp{\T}.
\]
The left-to-right check succeeds, but the right-to-left check fails because
the lower bound of \T---$\anytyp$---is not a subtype of $\inttyp$:
\[ 
  ^R \T_{\anytyp}^{\anytyp} \vdash \inttyp <: \T \vdash ^R \T_{\anytyp}^{\anytyp},
  \qquad 
  ^R \T_{\anytyp}^{\anytyp} \vdash \T \nless: \inttyp.
\]
Without environment propagation, the constraint $\anytyp{<:}\T$ would have been
lost and the subtyping check succeeded.

\paragraph{Left and right variables.}
Left and right variables are treated differently by the subtyping algorithm.
\begin{itemize}
  \item Left variables never change in the environment, and subtyping should
  hold with respect to their declared bounds.
  Thus, if a left variable \T appears on the
  left of the judgment, then the judgment can be satisfied
  only if the upper bound of \T is smaller than $t$:
  \[ ^L \T_l^u \vdash \T <: t \vdash ^L\! \T_l^u\ \ \text{ if }\ \ 
     ^L \T_l^u \vdash u <: t \vdash ^L\!\T_l^u. \]
  If $^L \T$ appears on the right, then
  it is the lower bound of \T that must be a supertype of $t$:
  %
  \[ ^L \T_l^u \vdash t <: \T \vdash ^L\! \T_l^u \ \ \text{ if }\ \ 
     ^L \T_l^u \vdash t <: l \vdash ^L\!\T_l^u. \]
  This corresponds to the intuition that for a left-hand side existential type,
  subtyping should hold for all possible instantiations of the type variable.
  \item Right variables, on the other hand, may accrue subtype constraints
  in addition to their declared bounds;
  updated bounds are recorded in the output environment~$E'$.
  For example, if a right variable \T appears on the right of the judgment,
  its lower bound can become larger (but not larger than the upper bound):
  \[ ^R \T_l^u \vdash \t <: \T \vdash ^R\!\T_{\uniontyp{l, t}}^u \ \ \text{ if }\ \ 
     \t <:u. \]
  If the resulting constraints on a right variable are consistent,
  as checked by $\mathit{consistent}(\T, E)$, subtyping succeeds.
  This corresponds to the intuition that
  for a right-hand side existential type, subtyping holds
  if there exists a valid instantiation of the type variable.  
\end{itemize}
% The following paragraphs provide examples and describe the structure of the
% judgment in more detail, before focusing on the exact rules.

\paragraph{Environment structure.}
The environment has a non-trivial structure.  First, an
environment $E$ is composed of two stacks, denoted by
$E.curr$ and $E.past$.  The former, $E.curr$, is a
stack of variables currently in scope (growing on the right),
reflecting the order in which variables have been added to the scope.
In addition to variables, $E.curr$ records \emph{barriers}: tags pushed
to the environment whenever the subtype check encounters an invariant
constructor.  Barriers will be discussed later.
The second list, $E.past$,
keeps track of variables that are not any longer in scope.  Consider
the judgment:
\[
    \tupletyp{\wheret{\cstrt{\jlname{Ref}}{\S}}{\S <: \jlname{Int}}} \ <:\ 
    \wheret{\tupletyp{\cstrt{\jlname{Ref}}{\T}}}{\T}.
\]
In the derivation, the variable
\T is introduced before the variable \S, but \T's bounds refer to \S
in the judgment
\[ ^R \T_{\uniontyp{}}^{\anytyp}, ^L \S_{\uniontyp{}}^{\jlname{Int}} \vdash
   \cstrt{\jlname{Ref}}{\S} <: \cstrt{\jlname{Ref}}{\T} \vdash 
   ^R\!\T_S^S, ^L \S_{\uniontyp{}}^{\jlname{Int}}, \]
which appears in the derivation tree.
Discharged variables are thus stored in \(E.past\) and accessed whenever
required.  The subtyping rules guarantee that it is never necessary to
update the bounds of a no-longer-in-scope variable.  Relying on a
separate \(E.past\) environment avoids confusion when rules must
determine precisely the scope of each variable.
%, as motivated in the next paragraph.

%% \TODO{this example would fail before the consistency check. Is there another
% example to motivate consistency?}
% Because of the dependencies between right variables, the satisfiability of
% constraints needs to be checked before a right variable is discharged.
% For instance, the subtype relation
% \[
%     \tupletyp{\anytyp, \reftyp{\inttyp}} \nless: 
%     \wheret{\wheret{\tupletyp{\S, \reftyp{\T}}}{\S<:\T}}{\T}
% \]
% does not hold because the type variables are subject to the three
% unsatisfiable constraints below, for \cjl{Any} is not a subtype of \cjl{Int}:
% \[
% \anytyp <: \S \qquad\quad \S <: \T \qquad\quad  \inttyp <: \T <: \inttyp.
% \]
% The subtyping algorithm records these constraints in the environment
% as \( ^R \T_{\inttyp}^{\inttyp}, ^R\!\S_{\anytyp}^{\T} \).
% Note that initially, \T is introduced as $^R \T_{\uniontyp{}}^{\anytyp}$,
% so the check 
% \[
%   ^R \T_{\uniontyp{}}^{\anytyp}, ^R\!\S_{\uniontyp{}}^{\T} \vdash
%   \anytyp <: \S 
% \]
% and whenever
% a right-variable is discharged, it checks that its lower bound is a subtype of
% its upper bound.  In the example above, the derivation is invalidated
% by the failure of the consistency check for \S:
% %
% \[ ^R \T_{\inttyp}^{\inttyp}, ^R\!\S_{\anytyp}^{\T} \vdash \anytyp \nless: \T. \]

\paragraph{From forall/exist to exist/forall.}  In some cases,
enforcing the correct ordering of type variable quantifications
requires extra care.  Consider the judgment:
\[ \vectyp{\wheret{\vectyp{\T}}{\T}} \nless: 
  \wheret{\vectyp{\vectyp{\S}}}{\S}. \]
The type on the left denotes the set of all the vectors of
vectors of elements of some type; the type on the right
requires a common type for all the inner
vectors.  For instance, the value
\cjl{[ [1,2],["a","b"] ]} belongs to the first, but
not the second, type.
If the subtyping algorithm simply introduced variables \S and \T into
the environment, the following judgments would succeed, because
for all instances of \(T\) there is a matching type for \(S\):
\[
  ^R \S_{\uniontyp{}}^{\anytyp}, ^L\!\T_{\uniontyp{}}^{\anytyp} \vdash \T <: \S
  \qquad\text{ and }\qquad
  ^R \S_{\uniontyp{}}^{\anytyp}, ^L\!T_{\uniontyp{}}^{\anytyp} \vdash \S <: \T
\]
However, we must instead find an instance of \(\S\) such that 
the judgment holds forall \T: perhaps surprisingly, the outer invariant
construct \(\jlname{Vector}\) forces the inversion of the order of quantifications.
Instead of a forall/exist query we must solve an \emph{exist/forall} one.
To correctly account for inversion in the order of quantifications,
derivations must keep track of the relative ordering of
variable introductions and invariant constructors.  For this, the
environment \(E.curr\) is kept ordered, and
\emph{barrier} tags are pushed into \(E.curr\) whenever the derivation goes through
an invariant constructor in the rule \RLJ{App\_Inv}.

We say that a variable \(\S\) is \emph{outside} a variable
\(\T\) in an environment \(E\) if \(\S\) precedes \(\T\)
in \(E.curr\) and they are separated by a barrier tag in~\(E.curr\).  

In our running example, the first check thus becomes:
\[ ^R \S_{\uniontyp{}}^{\anytyp}, \Barrier, ^L\!\T_{\uniontyp{}}^{\anytyp} 
\vdash \T <: \S. \]
\noindent The environment correctly identifies the variable \S
as outside \T, and the judgment should thus be interpreted as
\emph{there exists an instance of \S such that, forall instances of
\T, \( \T <: \S \) holds}.  The variable \S must thus be
compared with the upper bound of \T, deriving \anytyp as the lower bound:
\[ 
  ^R \S_{\uniontyp{}}^{\anytyp}, \Barrier, ^L\!\T_{\uniontyp{}}^{\anytyp} 
  \vdash \anytyp <: \S \vdash ^R \S_{\anytyp}^{\anytyp}.
\]
Again, given \S outside \T, the right-to-left check must now prove
\[ ^R \S_{\anytyp}^{\anytyp}, \Barrier, ^L\!T_{\uniontyp{}}^{\anytyp} 
\vdash \S <: \T, \]
that is, it must conclude that there exists an instance of \S
such that, forall instances of \T, \(\S <: \T\) holds.  In
other terms, the variable \S must be a subtype of the lower
bound of \T.  This fails, as expected.

Note that whenever the forall variable is constrained tightly and
quantifies over only one type, the exist/forall quantification can still
correctly succeed, as in the valid judgment below:
\[ 
  \reftyp{\wheret{\reftyp{\inttyp{<:}\T{<:}\inttyp}}{\T}} <: 
  \wheret{\reftyp{\reftyp{\S}}}{\S}.
\]

\paragraph{Operations on environment.}
Recall that an \emph{environment}, denoted by \(E\),
is composed by two stacks, denoted \(E.curr\) and \(E.past\),
of variable definitions and barriers.
The following operations are
defined on environments, where \(v\)  ranges over variable
definitions and barriers:
\begin{description}
\item[\normalfont\(\mathit{add}(v,E)\):] push \(v\) at top of
  \(E.curr\);
\item[\normalfont\(\mathit{del}(\T,E)\):] pop \(v\) from
  \(E.curr\), check that it defines the variable \(\T\), and
  push \(v\) at top of \(E.past\);

\item[\normalfont\(\mathit{del}(\Barrier,E)\):] pop \(v\) from
  \(E.curr\) and check that it is a barrier tag;

\item[\normalfont\(\mathit{search}(\T,E)\):] return the variable definition
  found for \(\T\) in \(E.curr\) or \(E.past\); fail if
  the variable definition is not found;

\item[\normalfont\(\mathit{update}(^R \T_l^u, E)\):] update the lower
  and upper bounds of the variable definition \(\T\) in
  \(E.curr\); %if the variable is found in \(E\) after a
  %barrier then increase the invariant occurrence counter, and the
  %covariant occurrence counter otherwise. 
  fail if the variable definition is not found;

\item[\normalfont\(\mathit{consistent}(\T,E)\):] search \(\T\) in
  \(E\).  If the search returns \(^L \T_l^u\), then return
  true if \(E \vdash l <: u\) and false otherwise; while building this judgment,
  recursive consistency checks are disabled.
  If the search returns \(^R \T_l^u\),
  then check if \(E \vdash l <: u\) is derivable.  If not, return
  false. % If yes, additionally check the diagonal rule: if
  % \(\textit{co} > 1\) and \(\textit{io} = 0\) then its lower-bound
  % \([[lb]]\) must be a concrete type, as checked by the
  % \([[is_concrete(lb)]]\) function.  The definition of this function
  % is non-trivial as a lower bound might depend on the values of other
  % type variable bounds. For example, \([[Vector{T}]]\) is equivalent
  % to a concrete type \([[Vector{Int}]]\) only if both the upper and
  % lower bounds of \([[T]]\) equal \([[Int]]\). At the time of writing,
  % Julia's implementation of \(\textit{is\_concrete}\) is heuristic and
  % does not catch all possible concrete types.  We omit its
  % formalisation but our artifact includes a
  % simple implementation.  
  The shorthand \(\mathit{consistent}(E)\) checks the consistency of all
  variables in the environment \(E\).
\end{description}

\paragraph{Distributivity.}
The rule~\RLJ{Tuple\_Lift\_Union}
rewrites tuple types on the left-hand side of the judgment into
disjunctive normal forms, making the distributivity of unions
with respect to tuples derivable.  This rule can be invoked multiple
times in a subtype derivation, enabling rewriting tuples
into disjunctive normal form even inside invariant
constructors.
Rewriting is performed by the auxiliary function
\(\mathit{lift\_union}(\t)\), which pulls unions and existential types out of
tuples, anticipating
syntactically the forall quantifications in a derivation.
Symmetrically, the rule~\RLJ{Tuple\_Unlift\_Union} performs
the opposite rewriting, delaying syntactically the exist
quantifications on union types appearing on the right-hand side of
a judgment.  The auxiliary function \(\mathit{unlift\_union}(\t)\) returns
a type \(\t'\) such that \(\t = \mathit{lift\_union}(\t')\). 

The need for the
\RLJ{Tuple\_Unlift\_Union} rule is
due to the \emph{complex interaction between invariant constructors, union
types, and existentials}.  For instance, the following judgment
\[
  \reftyp{\uniontyp{\tupletyp{\inttyp, \jlname{Bool}}}} <:
  \wheret{\reftyp{\tupletyp{\T}}}{\T}
\]
is valid because \(\T\) can be instantiated with
$\uniontyp{\inttyp, \jlname{Bool}}$.  However, building a derivation without the
\RLJ{Tuple\_Unlift\_Union} rule fails.  Initially, the
left-to-right check for invariant application generates the constraint
\(\T >: \uniontyp{\inttyp, \jlname{Bool}}\).  Thus, the right-to-left check
\[ ^R \T_{\uniontyp{\inttyp, \jlname{Bool}}}^{\anytyp} \vdash
  \tupletyp{\T} <: \uniontyp{\tupletyp{\inttyp, \jlname{Bool}}} \]
gets stuck trying to prove \(\T<:\inttyp\) or \(\T<:\jlname{Bool}\).  Rule
\RLJ{Tuple\_Unlift\_Union} enables rewriting the
right-to-left check into 
\[ ^R \T_{\uniontyp{\inttyp, \jlname{Bool}}}^{\anytyp} \vdash
  \tupletyp{\T} <: \tupletyp{\uniontyp{\inttyp, \jlname{Bool}}}, \]
which is provable because the existential quantifications is syntactically
delayed  due to the union on the right-hand side.

\paragraph{Subtyping existentials and variables.}
Rules~\RLJ{L\_Intro} and \RLJ{R\_Intro} add a
\wheret{}{}-introduced variable to the current environment, 
specifying the relevant forall (\textit{L}) or exist (\textit{R})
semantics, and attempt to build a subtype derivation in this extended
environment.  When the variable gets out of scope, it
is deleted from the \texttt{curr} list and added to the
\texttt{past} list of the environment. 
Variables with exist semantics might have had
their bounds updated in unsatisfiable way; before discarding them, the
consistency of their bounds is checked by the \(\mathit{consistent}(\T,E)\)
auxiliary function.

Note that existential types with inconsistent bounds, such as
\[
  \wheret{\tupletyp{\T}}{\anytyp{<:}\T{<:}\inttyp},
\]
are considered well-formed, but they are not subtypes of $\uniontyp{}$.
In Julia, attempting to instantiate such a type will produce an error:
\begin{lstlisting}
julia> (Tuple{T} where Any<:T<:Int){Int}
ERROR: TypeError: in Tuple, in T, expected Any<:T<:Int, got Type{Int}  
\end{lstlisting}

Subtyping for type variables is governed by
rules~\RLJ{L\_Left}, \RLJ{L\_Right},
\RLJ{R\_Left}, and \RLJ{R\_Right}.  Type variables
with forall semantics are replaced with the hardest-to-satisfy bound:
the upper bound if the variable is on the left of the judgment, and
the lower bound if the variable is on the right.  Variables with exist
semantics are instead replaced with their easiest-to-satisfy bound,
and, to keep track of the match, bounds of these variables are updated
if a successful derivation is found, reflecting their new bound.  By
symmetry, one would expect the rule~\RLJ{R\_Left} to update
\(\T\) upper bound with \(\t \cap u\). 
Until our work on~\cite{bib:zappa-nardelli:julia-sub:oopsla:2018} started, it
was believed that, because of invariance, the explicit ordering of the
checks performed by rule~\RLJ{App\_Inv} would ensure that \(\t <: u\) had
already been checked by rule~\RLJ{R\_Right}.  Therefore, it
would always hold that \(\t = \t \cap u\), avoiding the need
to compute intersections of Julia types. This
turned out to be false.  Consider the following example:
\[
  \begin{array}{c}
    \vectyp{\vectyp{\anytyp}} \\
    <: \\
    \wheret{\vectyp{\uniontyp{\vectyp{\anytyp}, \vectyp{\T}}}}{\T{<:}\inttyp}.  
  \end{array}
\]\label{juliabug:rleft}
\noindent This judgment contradicts the idea that \(\vectyp{\T}\)
can be a subtype of \(\vectyp{\anytyp}\) only if \(\T\) is
equivalent to \(\anytyp\), which is not possible here.  However,
at the time working on~\cite{bib:zappa-nardelli:julia-sub:oopsla:2018},
both Julia and our specification could build a derivation for it: due to
the existential on the right-hand side, the check that ought to ensure
\(\t <: u\), that is \(\anytyp <: \inttyp\), is skipped when
performing the left-to-right subtype check of the invariant
constructor \(\jlname{Vector}\). 
In response to this finding, Julia developers introduced a
\cjl{simple\_meet} function\footnote{Julia codebase already included a complex
algorithm that computes an approximation of intersection of two types, which
is used internally to compute dataflow information, but the algorithm is too
slow (and bug-ridden) to be integrated in the subtyping algorithm.}
to compute intersection in simple cases.
As of May 2023, the problematic judgment above does not hold.

To account for the exist/forall
quantification inversion, the \RLJ{R\_Right} does not apply
if the type on the left is
a left variable and the variables are in the exists/forall quantification
(the check \(\lnot\mathit{outside}(\T,\S,E)\) is responsible for this).
%Similar reasoning works for the rule \ottdrulename{R\_left}.
Matching R-L
variables is specially dealt by the \RLJ{R\_L} rule, which
also performs the necessary outside check: if the \(R\)-variable is
outside, then the bounds on the \(L\)-variable must constrain it to
only one type.  For this, the check \(u_2 <: l_2\) is sufficient, as the
other direction is later verified by the environment consistency check.

% \TODO{reflexivity in the paper is for all types and plain-bits values;
% here, I use it only for variables}

\section{Undecidability of Julia Subtyping}\label{sec:julia-sub:undec}
%% ======================================================================

It is not unusual for a statically typed programming language 
to have undecidable subtyping,
as witnessed by Java and Scala~\cite{bib:grigore:java-undec:2017,bib:hu:dot-undec:2020}.
In practice, the undecidability means that the
compiler might not terminate on some programs. Although undesirable,
such property can be acceptable if it manifests rarely and
allows for an expressive type system.

In a dynamically typed Julia, however, subtyping is used at run time---for
dispatch resolution. Even on rare occasions, consequences of
undecidability at run time are of greater concern than at compile time.
That is why the decidability of subtyping was one of the explicit goals
of the original design of the Julia language~\cite{bib:bezanson:julia:2015}.
To this end, Julia disallowed several features that were known to cause
undecidability, such as recursive constraints on type variables and
circularities in the inheritance hierarchy~\cite{bib:tate:taming-wildcards:2011}.

\begin{figure}
\[
\begin{array}{rcl}
  \interp{\mathit{Top}} &=& \text{\cjl{Union\{\}}}\\
  \interp{\alpha} &=& \alpha\\
  \interp{\forall\alpha\leq\ty.\ty'} &=&
    \text{\cjl{Tuple\{Ref\{}}\alpha\text{\cjl{\}, }}
    \interp{\ty'}\text{\cjl{\} where\ }}\alpha\text{\cjl{\ >:\ }}\interp{\ty}\\
\end{array}
\]
\caption{Encoding of \FSubN types in Julia}\label{fig:FSub-encoding}
\end{figure}

Despite the intentional simplifications in the type language,
Julia subtyping is in fact \emph{undecidable}.
As shown in~\TODO{Ben's thesis}, Julia can encode system
\FSubN, which is known to be undecidable~\cite{bib:pierce:bound-sub-undec:1992}.
\figref{fig:FSub-encoding} shows the encoding\footnote{Arrow %of \FSubN types
type is dropped as irrelevant to the undecidability result.},
with $\ty_1 \leq \ty_2$ in \FSubN defined as
$\interp{\ty_2} <: \interp{\ty_1}$ in Julia.
In practice, the undecidability %of Julia subtyping 
manifests itself with a \cjl{StackOverflowError}.
The reason is that internally, Julia relies on a dedicated stack
to resolve subtyping
and terminates the program when the stack reaches a certain limit.
%Thus, in practice, subtyping checks that showcase undecidability, such as
%the Ghelli example, often manifest with a \cjl{StackOverflowError}
%rather than non-termination.

Although the undecidability of a particular subtyping algorithm
does not necessarily mean that decidable subtyping for the same
language of types does not exist, I {conjecture} that
\begin{quotation}\emph{
  in the case of Julia's type language, there is no decidable subtype relation 
  that would match the intended subtyping behavior
  described in Sections \ref{sec:julia-sub:overview} and
  \ref{sec:julia-sub:lambda-julia}.
}\end{quotation}
The key problem is the interaction of
impredicative existential types, invariant constructors, and unions.
In what follows, I intentionally depart from the subtyping judgment
presented in the previous section~\ref{sec:julia-sub:lambda-julia},
as I am interested in the existence of some other, decidable subtype relation.

First, recall that parametric datatypes are invariant, meaning that
types such as $\reftyp{t}$ and $\reftyp{t'}$ are subtypes
only if their type arguments $t$ and $t'$ are equivalent.
The equivalence of types is expressed via subtyping:
$t$ and $t'$ are equivalent
if both $t <: t'$ and $t' <: t$ hold.
To check for equivalence, one can either rely on subtyping directly,
or use a separate relation $t \approx t'$ such that 
$t \approx t' \ \implies\ t <: t'\ \land\ t' <: t$.

Next, recall that an existential type $\wheret{t}{l{<:}\T{<:}u}$ is meant to 
represent a union of types $t[t'/\T]$ for all possible valid instantiations
$l <: t' <: u$ of the type variable $\T$.
Thus, whenever subtyping is checked for some 
$t_1 <: (\wheret{t}{l{<:}\T{<:}u})$, the subtyping algorithm needs to check that
there exists a valid instantiation $t'$ of $\T$ such that $t_1 <: t[t'/\T]$.
From now on, I will refer to such variable \T (that is, a variable introduced
by an existential type on the right-hand side of the judgment) as a
\textbf{unification variable}; in \secref{sec:julia-sub:lambda-julia},
it was called an exist/right variable.

Consider the following subtype query 
\[
  \begin{array}{ll}
    \jlname{Tuple}\{\vectyp{\wheret{\reftyp{\t'^S}}{l'{<:}\S{<:}u'}}, &
      t'\,\}\\
    \multicolumn{2}{c}{<:} \\
    \jlname{Tuple}\{\vectyp{t_1^{\T}}, & t_2^{\T}\} 
      \ \textbf{\texttt{where}}\ l{<:}\T{<:}u,
  \end{array}
\]
where \S occurs in $t'^S$ and \T occurs in both $t_1^{\T}$ and $t_2^{\T}$.
Let us walk through possible steps of a subtyping algorithm \algo.
\begin{enumerate}
  \item Because the right-hand side type is an existential,
    \T is a unification variable; \algo can remember the variable and proceed
    to subtyping of
    \[ 
      \begin{array}{c}
        \tupletyp{\vectyp{\wheret{\reftyp{\t'^S}}{l'{<:}\S{<:}u'}}, t'} \\
        <: \\
        \tupletyp{\vectyp{t_1^{\T}}, t_2^{\T}}. 
      \end{array}
    \]
  \item Both sides of the subtyping query are now tuples of the matching length.
    Tuples are covariant, so \algo needs to check that ther corresponding 
    components are subtypes, i.e.,
    \[ 
      \vectyp{\wheret{\reftyp{\t'^S}}{l'{<:}\S{<:}u'}}\ <:\ \vectyp{t_1^{\T}} 
      \ \ \text{and}\ \ t' <: t_2^{\T}.
    \]
    Since the unification variable \T appears in both $t_1^{\T}$ and $t_2^{\T}$,
    \emph{both subtyping queries can impose constraints on \T}.
    \begin{enumerate}
      \item The first tuple components are both invariant constructors,
        \[ 
          \vectyp{\wheret{\reftyp{\t'^S}}{l'{<:}\S{<:}u'}} 
          \ <:\  
          \vectyp{t_1^{\T}}, 
        \]
        so \algo needs to check that their type arguments are equivalent.
        Let \algo use subtyping for the equivalence check and focus
        on the second, right-to-left check:
        \[ t_1^{\T}\ <:\ \wheret{\reftyp{\t'^S}}{l'{<:}\S{<:}u'}. \]
        \begin{enumerate}
          \item The right-hand side type is an existential, so \S is unification
            variable; \algo can remember the variable and proceed to 
            subtyping of \[ t_1^{\T} <: \reftyp{\t'^S}. \]
          \item Let us assume that \algo successfully processes this subtyping
            query. Note that \emph{both sides of the query contain
            unification variables}, for \T occurs in $t_1^{\T}$
            and \S occurs in $\reftyp{\t'^S}$.
            Thus, the unification variables \S and \T might
            be \emph{constraining each other}.
          \item\label{item:sub-stuck} \algo needs to resolve the unification variable \S, that is,
            check that constraints that were necessary to satisfy 
            \[ t_1^{\T} <: \reftyp{\t'^S} \]
            are consistent with each other as well as the declared bounds
            $l'$ and $u'$.
            However, \S might be constrained by the unification variable \T,
            and not all constraints on \T are known, for $t' <: t_2^{\T}$
            has not been processed yet.
            Thus, \textbf{the subtyping algorithm \algo is stuck.}
        \end{enumerate}
    \end{enumerate}
  %\item Check that all the constraints
\end{enumerate}

How can the problem in \ref{item:sub-stuck} be addressed?
%\emph{Delayed resolution of unification variables.}
In the example, \S cannot be resolved because not all relevant constraints
are available. Perhaps, instead of trying to resolve the variable at the point 
where it goes out of lexical scope, \algo could instead 
store the constraints and resolve them later.
However, another---more challenging---problem is that the two unification
variables \S and \T may be \textbf{arbitrarily constraining each other},
i.e. appear in arbitrary positions within constraining types. In the presence of
impredicative existential types, constraints may have non-trivial solutions.
For example, the following constraint set is satisfiable when both
\S and \T are instantiated with $\wheret{\reftyp{\Q}}{\Q}$:
\[
  \{ \reftyp{\T} <: \S, \quad \reftyp{\reftyp{\S}} <: \T, \quad \S <: \T \}
\]
In general, for an arbitrary set of constraints containing mutually
dependent unification variables, finding a solution algorithmically is
not straightforward if not undecidable.
% In general,
% \begin{quotation}\emph{there does not appear to be an ordering of unification 
% variables that would guarantee both the termination of constraints resolution
% and finding a solution when it exists.
% }\end{quotation}
%and need to be resolved simultaneously.
% \begin{quotation}\emph{
%   In general, there does not seem to be an order of unification variables
%   that would allow for complete constraints resolution.
% }\end{quotation}
%
% T <: Ref{Q}
% Ref{S} <: T
% S <: Q
% S --> T <-- Q
% ^-----------|
%
Instead, I suggest \textbf{eliminating mutual dependencies
between unification variables}
and consider two possible angles of attack.
\begin{enumerate}
  \item \emph{Prevent unification variables from moving to the left-hand side
    of subtyping.} Recall that unification variables are introduced by
    existential types on the right. The only way for a unification variable to
    ``travel'' to the left is a right-to-left subtyping check for an
    invariant constructor. Thus, instead of using subtyping to check for
    equivalence of types, \algo could rely on a separate relation
    $t \approx t'$ and keep unification variables on the right.
    Unfortunately, due to union types, checking for equivalence
    without relying on subtyping might not be possible.
    For instance, consider the following example:
    \[
      \vectyp{\reftyp{\inttyp}} 
      <: 
      \wheret{\vectyp{\uniontyp{\reftyp{\inttyp}, \reftyp{\T}}}}{\T}.
    \]
    Instantiating \T with \inttyp is the only solution that would make types
    $\reftyp{\inttyp}$ and $\uniontyp{\reftyp{\inttyp}, \reftyp{\T}}$
    equivalent. However, to find the solution, \algo would effectively need
    to check $\reftyp{\T} <: \reftyp{\inttyp}$, bringing the unification
    variable to the left.
  \item\label{item:remove-uni-vars} 
    \emph{Prevent new unification variables from appearing on the right-hand
    side of subtyping.} Assuming that \algo has to rely on subtyping 
    for the equivalence check, unification variables introduced by top-level
    existential types (i.e. existential types bound outside invariant
    constructors) will appear on the left-hand side. Once that happens,
    existential types bound \emph{inside} invariant constructors will be the
    only source of new unification variables on the right.
    Thus, the elimination of variable-introducing existential types inside 
    invariant constructors would prevent \algo from producing unwanted
    dependencies between unification variables.
\end{enumerate}

In the next chapter, I present a decidable subtype relation that
follows the strategy \ref{item:remove-uni-vars} by restricting
existential types inside invariant constructors.
A simpler approach would be to eliminate impredicative existential types
entirely, that is, allow only top-level existential types such as
\[ \wheret{\vectyp{\vectyp{\T}}}{\T} \]
but not
\[ \vectyp{\wheret{\vectyp{\T}}{\T}}. \]
However, as previously discussed, %impredicative existential types
types like the latter \jlname{Vector} type above are used by Julia programmers 
to represent heterogeneous data, so the simple approach seems unsatisfactory.
