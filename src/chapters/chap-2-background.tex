\chapter{Background}

\section{Overview of the Julia Language}

Julia is a high-level, dynamic programming language for scientific computing~\cite{TODO}.
It was designed to provide good performance as well as productivity features and
the ease of use~\cite{TODO}.
For performance, Julia relies on an optimizing JIT compiler.
For productivity, the language provides garbage collection, dynamic typing, and
multiple dispatch. 

\begin{figure}[t]
%-(x::Date, y::Week) = Date(UTD(value(x) - 7*value(y)))    
\begin{julia}
-(x::BigInt) = MPZ.neg(x, y)
-(x::BigInt, y::BigInt) = MPZ.sub(x, y)
-(x::T, y::T) where T<:Union{Int16, Int32, ..., UInt128} = sub_int(x, y)
-(m::Missing, n::Number) = missing
-(A::AbstractArray{T,N} where {T,N}) = broadcast_preserving_zero_d(-, A)
\end{julia}
\caption{Several method definitions of generic function~\cjl{(-)}
in~Julia}\label{fig:code:subtraction}
\end{figure}

\tdef{Multiple dynamic dispatch}~\cite{TODO} is the core paradigm of the Julia
language. The dispatch mechanism allows a function, called \emph{generic
function}, to have multiple implementations, called \emph{methods}, that are
tailored to different argument types. For example, \figref{fig:code:subtraction}
shows several method definitions of \cjl{(-)}, which is used as both unary
negation (lines~1 and 5) and binary subtraction (lines 2--4).
At \emph{run time}\footnote{Statically typed languages often support
\emph{method overloading}. The difference between method overloading and method
dispatch is that overloading is resolved at compile time, using static types of
the arguments, whereas dispatch is resolved at run-time.},
every function call in the program is dispatched to the
\emph{most specific applicable} method, which is determined based on the
types of the argument values. If such a single best method does not exist,
an error is raised.
\secref{TODO} describes this process in more detail, but for now, it suffices to
know that dispatch resolution relies on \tdef{subtyping}.
Notably, Julia does not allow the user to call a method of a generic function
directly: the only way to reach a method is via the dispatch mechanism.
Thus, whenever a method is called, its arguments are guaranteed to be
subtypes of the declared type annotations.
%Thus, types impact the semantics of a program despite the language being dynamically typed.

Julia has a non-trivial \tdef{language of types}, some of which are demonstrated
in~\figref{fig:code:subtraction}. In addition to nominal types such as
\cjl{BigInt} and \cjl{Number}, the language also supports set-theoretic union
types (e.g. \cjl{Union\{Int16,}$\ldots,$ \cjl{UInt128\}} in line~3),
covariant tuple types written with \cjl{Tuple} (e.g. \cjl{Tuple\{String, Number\}}),
invariant parametric types (e.g. \cjl{AbstractArray\{T,N\}} in line~5),
and so-called union-all types, which are written with \cjl{where} (lines~3 and 5).
A union-all type \cjl{t where T} represents a union of types \cjl{t} for all
valid instantiations of the type variable \cjl{T}. \citet{TODO} provide a detailed
account of Julia types and their subtyping relation.

One of the key notions related to types in Julia is the distinction between
\emph{concrete} and \emph{abstract} types. A concrete type is a type that
describes the representation of a value; for any value, its concrete type can be
obtained with the \cjl{typeof} operator. Concrete types include primitive types
such as \cjl{Int128} and composite \cjl{struct} types (either mutable or
immutable). Any concrete type definition in Julia is final: a concrete type does
not have subtypes other than itself. However, every concrete type has a single
declared supertype, which is an abstract nominal type. Such types can be used
to create a nominal subtyping hierarchy, but they cannot be instantiated with
values and have no fields. Other categories of abstract types are union types
such as \cjl{Union\{Int16,}$\ldots,$ \cjl{UInt128\}}, and union-all types
such as \cjl{Vector\{T\} where T} (in Julia, such a type can be written shorter
as \cjl{Vector}). Note, however, that every particular instantiation of
\cjl{Vector}, e.g. \cjl{Vector\{Number\}}, is a concrete type.
The bottom type represented with the empty union, \cjl{Union\{\}}, is neither
concrete nor abstract: it has no values and is a subtype of all types.

\figref{fig:code:user-def-types} provides several examples of user-defined
concrete (on the left) and abstract (on the right) types. Parametric types (both
abstract and concrete) can declare lower and upper bounds on type variables;
for example, type \cjl{Rational\{T\}} requires \cjl{T} to be a subtype of
abstract \cjl{Integer}.
Supertypes in type definitions are declared to the right of~\cjl{<:}.
For example, \cjl{Int128} is a subtype of \cjl{Signed}, and \cjl{Signed} is a
subtype of \cjl{Integer}. If the supertype declaration is omitted, like in
\cjl{AbstractSet\{T\}}, the supertype defaults to \cjl{Any},
which is the supertype of all types.

\begin{figure}[t] 
\begin{minipage}{5.5cm}
\begin{julia}
primitive type Int128 <: Signed 128
end

struct Rational{T<:Integer} <: Real
  num::T
  den::T
end

mutable struct
  BitSet <: AbstractSet{Int}
  ...
end
\end{julia}
% struct Missing end
% bits::Vector{UInt64}
% offset::Int
\end{minipage}
\hspace{1.2cm}
\begin{minipage}{4.8cm}
\begin{julia}
abstract type Signed <: Integer
end

abstract type AbstractSet{T}
end
\end{julia}
% RefValue{T}() where {T} = new()
% RefValue{T}(x) where {T} = new(x)    
\end{minipage}
\caption{Examples of type definitions:
  concrete (left) and abstract (right)}\label{fig:code:user-def-types}
\end{figure}