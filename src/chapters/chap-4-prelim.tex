\chapter{Preliminary work}\label{chap:4}

In this chapter, I briefly describe preliminary work
related to subtyping and run-time semantics of Julia.

\paragraph{A reconstruction of Julia subtyping~\cite{TODO}.} 
This work is the result of a collaborative effort to provide a
readable specification of Julia subtyping.
Before that, an incomplete and outdated definition of subtyping existed only
in~\cite{TODO}, with the actual implementation of subtyping ($\sim$3000 lines of
heavily optimized C~code) being the only reference point.

In~\cite{TODO}, we define subtyping in the form of a judgment
\[
  \ljsub{E}{t}{t'}{E'}.
\]
Here, $E$ is a type variable environment that contains two kinds of variables,
forall (also called left) and exist (also called right).
A forall variable is added to the environment
when an existential type appears on the left of the subtyping judgment,
as in \cjl{(Vector\{X\} where X) <: t'}. Reflecting the intuition
that subtyping should hold for all possible instantiations of the type variable,
such variable never changes in the environment.
However, when an existential type appears on the right,
as in \cjl{t <: Vector\{Q\} where Q}, the variable is
added as an exist variable. Reflecting the intuition that subtyping of an
existential type on the right holds if there exists a valid instantiation
of the type variable, this exist variable may be constrained as a result of a
subtyping check. Constraints on possible instantiations take the form of updated
variable bounds, and these updates produce the environment~$E'$.
For example, if \cjl{Q} is an exist variable with bounds
\cjl{Union\{\}<:Q<:Any}, then
\[
  \ljsub{\mathtt{Q}_\text{\cjl{Union\{\}}}^\text{\cjl{Any}}}
    {\text{\cjl{Int}}}{\mathtt{Q}}
    {\mathtt{Q}_\text{\cjl{Int}}^\text{\cjl{Any}}},
\]
i.e., \cjl{Int<:Q} results in updating \cjl{Q} to \cjl{Int<:Q<:Any}.

Having done \cite{TODO}, we were able to identify
that subtyping in Julia is undecidable. Furthermore, this work highlighted
several other problems with subtyping which I plan to address in the proposal.
For example, the diagonal rule (discussed in \secref{sec:2:subtyping})
is determined not from the type itself, but based on the subtyping check with
another type. As a result, the same existential type may be constrained to
a concrete type variable in one subtyping judgment but not the other.
This makes it hard, if not impossible, to reason about properties of subtyping
such as reflexivity and transitivity.

\paragraph{Tag-based semantic subtyping for nominal types, tuples, and
unions~\cite{TODO}.}
Although subtyping in Julia is intended to follow the semantic subtyping
intuition, there is no formal set-theoretic model of Julia types.
In \cite{TODO}, I proposed a semantic interpretation of (a subset of) Julia
types \ty as sets of type tags \gty, which correspond to concrete types.
Then, for a language of non-parametric nominal types, tuples, and unions,
subtyping can be defined as the set inclusion of interpretations
$\interp{\ty} \subseteq \interp{\ty'}$.
% While the treatment of tuples and unions is completely standard, nominal types
% are not as straightforward: interpreting an abstract type as a set of
% its concrete subtypes (e.g. $\interp{\text{\cjl{Signed}}} =
% \{\text{\cjl{Int8, Int16, ..., Int128}}\}$) would lead to brittle programs.
% Namely, because subtyping is used at run time to process method definitions and 
% dynamic dispatch, defining a new concrete subtype of an abstract type would
% change the subtyping relation and
% could cause the existing code to execute differently.
%It is worth emphasizing that Julia subtyping contradicts the set-theoretic
%interpretation in its treatment of the bottom type \cjl{Union\{\}}.
%Semantically, both \cjl{Union\{\}} and \cjl{Tuple\{Union\{\}\}} represent the
%empty set and are thus equivalent. However, in Julia,
%\cjl{Tuple\{Union\{\}\}} is not a subtype of \cjl{Union\{\}}.
However, in the presence of invariant type constructors such as \cjl{Vector\{...\}},
types are given an indexed interpretation $\interp{\cdot}_n$.
In particular, a concrete type constructor \cjl{Name\{...\}} is interpreted as
\[
\interp{\text{\cjl{Name\{}}\ty\text{\cjl{\}}}}_{n+1} =
\{ \text{\cjl{Name\{}}\ty'\text{\cjl{\}}}
\ |\ \interp{\ty'}_n = \interp{\ty}_n \},
\]
and subtyping is defined as
\[
  \ty <: \ty' \quad \equiv \quad
  \forall n.\ \interp{\ty}_n \subseteq \interp{\ty'}_n.
\]
The reason $\text{\cjl{Name\{}}\ty\text{\cjl{\}}}$ is not interpreted simply as
a singleton set $\{ \text{\cjl{Name\{}}\ty\text{\cjl{\}}} \}$
is that type tags $\text{\cjl{Name\{}}\ty\text{\cjl{\}}}$ and
$\text{\cjl{Name\{}}\ty'\text{\cjl{\}}}$ can have syntactically different
but semantically equivalent type parameters \ty and $\ty'$.
Despite the more complicated indexed interpretation, subtyping has
an equivalent, standard syntactic definition $\ty \leq \ty'$ where
$\text{\cjl{Name\{}}\ty\text{\cjl{\}}} \leq
\text{\cjl{Name\{}}\ty'\text{\cjl{\}}}$
holds if $\ty \leq \ty'$ and $\ty' \leq \ty$.

\paragraph{A model of Julia's JIT~\cite{TODO}.}
Using an abstract machine modeled after Julia's JIT compiler, this work formally
defines the property of a method definition that impacts the ability of
the compiler to optimize the code: the property is called type stability.
Although type stability is not directly related to the topic of this thesis
proposal, having defined a model of the JIT compiler, I found that
(1)~the correctness of JIT compilation depends on the soundness of type
inference, and (2)~concrete types and the ability of type inference to infer
concrete types of expressions are conducive to optimizations.
These observations emphasize that despite Julia being a dynamic language,
subtyping and the type language are an integral part of the compiler
and Julia's performance.

