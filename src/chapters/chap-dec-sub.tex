\chapter{Decidable Subtyping of Existential Types}%
\label{chap:dec-sub}

This chapter presents a decidable subtype relation for the core language
of Julia types that includes covariant tuples, invariant type constructors,
unions, existential types, and distributivity.
As discussed in \secref{sec:julia-sub:undec}, it is the interaction of
impredicative existential types, invariant constructors, and unions that makes
Julia subtyping so challenging to decide, which is why I focus
on this sublanguage first.

The decidability of subtyping for the core language is achieved by
restricting existential types allowed to appear inside invariant 
constructors. In particular, the restriction limits such inner existentials 
to the ones expressible with Java wildcards.
This reduces the space of types representing heterogeneous data,
but top-level existential types, which are used to represent parametric method
definitions, remain intact.

\TODO{Evaluation and extensions for diagonals and nominals later}

% In this chapter, I present a decidable subtype relation for the following 
% sublanguage of Julia types:
% \begin{itemize}
%     \item covariant tuples;
%     \item invariant type constructors 
%         (without nominal subtyping hierarchy);
%     \item unions that distribute over tuples;
%     \item top-level bounded existential types that distribute over tuples;
%     \item restricted bounded existential types for invariant constructors.
% \end{itemize}

As outlined in~\secref{sec:julia-sub:undec}
(strategy \ref{item:remove-uni-vars} on page~\pageref{item:remove-uni-vars}),
the key to obtaining a decidable subtype relation for Julia is to
\emph{eliminate variable-introducing existential types inside invariant
constructors}. Notably, such existentials do not need to be eliminated
entirely. Instead, they can be \textbf{restricted} to the type grammar
of \emph{Java wildcards}~\cite{bib:torgersen:wildcards:2004}.

In Java, the wildcards mechanism provides \emph{use-site
variance}~\cite{bib:thorup:unif-genericity:1999}, a restricted form
of bounded existential types~\cite{bib:igarashi:variance:2002}.
For example, the wildcard type 
\[ \code{List<?\ \textbf{extends} Number>} \]
represents an existential type 
\[ \code{$\exists$X<:Number.List<X>}. \]
Thus, the type \code{List<List<?>{>}} represents a heterogeneous
list of lists where inner lists may have different element types.
With existential types, the above type can be written as
\[ \code{List<$\exists$X.List<X>{>}}, \]
which corresponds to the following Julia type:
\[ \text{\cjl{Vector\{Vector\{T\} where T\}}}. \]

Note that with wildcards, every occurrence of \code{``?''} introduces a 
fresh existential variable that \emph{cannot be referred to by name},
and as such, has the following properties:
\begin{enumerate}
    \item occurs in the type exactly once---as an argument of a type
        constructor;
    \item is bound immediately outside the containing type constructor;
    \item cannot have recursive constraints.
\end{enumerate}
For example, the type \code{List<Pair<?, ?>{>}} represents a heterogeneous
list of pairs \code{List<$\exists$X.$\exists$Y.Pair<X,Y>{>}},
but there is no way of restricting both elements of the pair to the same type
like with full-fledged existential types: 
\code{List<$\exists$X.Pair<X,X>{>}}.

Due to this ``namelessness'' property,
subtyping of wildcards-induced existential types can be checked without 
explicitly introducing existential variables.
For example, the following subtyping
\[
    \code{List<?\ \textbf{super}\ l\ \textbf{extends}\ u>}
    \ \ <:\ \ 
    \code{List<?\ \textbf{super}\ l'\ \textbf{extends}\ u'>}
\]
holds as long as the bounds of the implicit variable on the right-hand side
contain the bounds of the left-hand side one, that is,
\[
    \code{l'} <: \code{l} \quad\text{and}\quad \code{u} <: \code{u'}.
\]
Thus, in the case of Julia subtyping,
\begin{quotation}\emph{
    wildcards-induced existential types can be allowed inside
    invariant constructors without jeopardizing the decidability of subtyping,
}\end{quotation}
as they will not introduce new unification variables.

Conveniently, the Julia language already supports a shorthand notation
corresponding to the proposed restriction\footnote{As of June 2023,
it is impossible to specify both lower and upper bounds with this notation.}.
For instance, types \cjl{Vector}, \cjl{Vector\{<:Number\}}, and \cjl{Vector\{>:Int\}}
represent \cjl{Vector\{T\} where T}, \cjl{Vector\{T\} where T<:Number},
and \cjl{Vector\{T\} where T>:Int}, respectively.

The next section provides a complete definition of decidable subtyping
for the core language of Julia types, with the above described restriction
on existential types inside invariant constructors.
In the remaining sections of this chapter, I prove several properties
of subtyping, in particular,
decidability of subtyping (\thmref{thm:subtysig-terminates})
and
soundness of constraints resolution (\thmref{thm:solvectr-sound}).

\section{Definition of Subtyping}%
\label{sec:dec-sub:defs}
%% ======================================================================

%% Grammar
%% *********************************************************

\begin{figure}[t]
\footnotesize
\makebox[\textwidth][c]{
\begin{tabular}{l@{\hspace{4mm}}l}
    $\begin{array}{rcll}
        \tysig
        &::=& & \textit{Type signature} \\
        &\Alt& \tyany & \text{top} \\
        &\Alt& \tybot & \text{bottom} \\
        &\Alt& \vany
            & \text{type variable} \\
        &\Alt& \typair{\tysig_1}{\tysig_2}
            & \text{covariant tuple} \\        
        &\Alt& \tyinv\iname\rexvars
            & \text{invariant constr.} \\
        &\Alt& \tyunion{\tysig_1}{\tysig_2}
            & \text{union} \\
        &\Alt& \tyexist{\vany}{\tylb}{\tyub}{\tysig}
            & \text{existential} \\
        \\
        \vany
        &::=& & \textit{Type variable} \\
        &\Alt& \vx, \vy, \ldots & \text{universal var.} \\
        &\Alt& \va, \vb, \ldots & \text{unification var.} \\
        \\
        \rexvar
        &::=& \rexvarbound{\tylb}{\tyub} & \textit{Restricted existential var.} \\
    \end{array}$ 
    &
    $\begin{array}{rcll}
        \ty, l, u
        &::=& & \textit{Type} \\
        &\Alt& \tyany & \text{top} \\
        &\Alt& \tybot & \text{bottom} \\
        &\Alt& \vany
            & \text{type variable} \\
        &\Alt& \typair{\ty_1}{\ty_2}
            & \text{covariant tuple} \\        
        &\Alt& \tyinv\iname\rexvars
            & \text{invariant constr.} \\
        &\Alt& \tyunion{\ty_1}{\ty_2}
            & \text{union} \\
        \\ \\ \\ \\ \\ \\ \\ \\
    \end{array}$
\end{tabular}
}
\caption{Grammar of type signatures and types}\label{fig:ty-grammar}
\end{figure}

The restricted type language is given in \figref{fig:ty-grammar}.
For brevity, I switch to a shorter notation, with \tyany, \tybot, 
$\times$, $\cup$, and $\exists$ used instead of
\cjl{Any}, \cjl{Union\{\}}, \cjl{Tuple}, \cjl{Union}, and \cjl{where},
respectively. \iname (a shorthand for \tyinv\iname{}) and 
\tyinv\iname{\ldots} represent
non-parametric and invariant parametric datatypes, where datatype
declarations are implicit and do not impose restrictions on type parameters.

The type language distinguishes between more expressive
\textbf{type signatures} \tysig
and less expressive \textbf{types} \ty:
\begin{itemize}
    \item type signatures \tysig correspond to method type signatures
      and allow for explicit existential types bound outside
      invariant constructors; variable bounds cannot be recursive but are
      allowed to refer to other variables in scope;
    \item types \ty describe data; they are similar to type signatures
      but support only a restricted form of existential types
      \tyinv\iname\rexvars.
\end{itemize}
Semantically, an existential $\tyexist{\vany}{\tylb}{\tyub}{\tysig}$ 
represents a union of $\subst{\tysig}{\substel{\vany}{\ty}}$ for all valid
\emph{type} instantiations $\tylb <: \ty <: \tyub$ of the type variable \vany.
In the spirit of Java wildcards, a \textbf{restricted existential type} 
\tyinv\iname{\rexvarbound{\tylb_1}{\tyub_1},\ldots} %\footnote{%
%in \figref{fig:ty-grammar}, it is written
%as \tyinv\iname\rexvars, with \rexvar being \rexvarbound\tylb\tyub.}
represents
\tyexist{\vx}{\tylb_1}{\tyub_1}{\exists\ldots\tyinv\iname{\vx_1,\ldots}}.
\tyinv\iname{\ty_1,\ldots} is a shorthand for the tightly-bound existential
\tyinv\iname{\rexvarbound{\ty_1}{\ty_1},\ldots}.
Note that the same semantic type can have multiple syntactic representations.
For example, the following pairs of types are equivalent:
\[
\begin{array}{ccc}
    \tyint &\approx& 
        \tyunion{\tyint}{\tyint} \\
    \typair{(\tyunion{\tyint}{\tyflt})}{\tystr} &\approx&
        \tyunion{(\typair{\tyint}{\tystr})}{(\typair{\tyflt}{\tystr})} \\
    \tyexist{\vany}{\tybot}{\tystr}{\typair{\vany}{\tyint}} &\approx& 
        \typair{\tystr}{\tyint} \\
    \tyexist{\vany}{\tybot}{\tyany}{\tyinv\nref\vany} &\approx&
        \tyinv\nref{\rexvarbound\tybot\tyany} \\
\end{array}
\]

% The key to decidable subtyping is to restrict existential types within
% invariant constructors to use-site variance of the form
% \tyinv\iname{\rexvarbound{\tylb}{\tyub},\ldots},
% similar to Java wildcards.
% Unrestricted existential types are supported only at the top level,
% in type signatures \tysig.

% Types and type signatures are defined in \figref{fig:ty-grammar}.

To visually aid the perception of inference rules that define subtyping,
I use two styles of type variables: $\vx, \vy, \ldots$ (referred to as
universal variables) and $\va, \vb, \ldots$ (referred to as unification
variables), with \vany used when the distinction is irrelevant.
\textbf{Unification} variables, discussed extensively
in \secref{sec:julia-sub:undec}, are variables introduced by existential
types on the right-hand side of a subtyping judgment.
Universal variables are variables introduced on the left.
In \secref{sec:julia-sub:lambda-julia}, universal and unification variables
were called left/forall and right/exist, respectively.

In the next few paragraphs, I first give an overview of the subtyping
algorithm for the type language in~\figref{fig:ty-grammar},
and then discuss its exact definition and decidability.
Detailed proofs are provided in the following sections.
%Although the overview points to figures with exact definitions,
I suggest that the reader skips figures with subtyping rules
while reading the overview for the first time.

% we use \vx, \vy, etc. to denote universal variables
% and \va, \vb, etc. to denote unification variables.
% Unification variables are constrained variables.

\subsection{Overview}
%% *********************************************************

Subtyping starts with subtyping of type signatures
(\figref{fig:subtyping-tysigs}):
\[ \subtysigdflt\tysig{\tysig'}. \]

Here, all explicit existential variables from \tysig (universal variables)
are introduced into environment \AEnv (defined in \figref{fig:subty-aux}), 
and variables from $\tysig'$ (unification variables) are introduced into \UEnv.
To reach all existential types, it may be necessary to apply distributivity
and go through union types. The following derivation provides an example:
\makebox[\textwidth][c]{
\begin{minipage}{\ruleswidth}
\begin{mathpar}
\small
\inferrule*[right=\footnotesize\RSS{UnionRight}]
{ 
    \inferrule*[right=\footnotesize\RSS{ExistLeft}]
    { 
        \inferrule*[right=\footnotesize\RSS{ExistRight}]
        { 
            \inferrule[\footnotesize\RSS{Types}]
            { \text{<discussed below>} }
            { \subtysig{\vx{\symsub}\tyint}{\va}  
                {\typair{\tystr}{\tyinv\nref\vx}}
                {\typair{\tyany}{\tyinv\nref\va}}
            }   
        }
        { \subtysig{\vx{\symsub}\tyint}{\EmptyEnv}  
            {\typair{\tystr}{\tyinv\nref\vx}}
            {\tyexistnob{\va}{(\typair{\tyany}{\tyinv\nref\va})}}
        }
    }
    { \subtysig{\EmptyEnv}{\EmptyEnv} 
        {\typair{\tystr}{(\tyexistnob{\vx{\symsub}\tyint}{\tyinv\nref\vx})}}
        {\tyexistnob{\va}{(\typair{\tyany}{\tyinv\nref\va})}}
    }
}
{ \subtysig{\EmptyEnv}{\EmptyEnv}
    {\typair{\tystr}{(\tyexistnob{\vx{\symsub}\tyint}{\tyinv\nref\vx})}}
    {\tyunion{\tyint}{\tyexistnob{\va}{(\typair{\tyany}{\tyinv\nref\va})}}} 
}
\\
\end{mathpar}
\end{minipage}}
First, \RSS{UnionRight} picks the second type on the right.
Second, because of the distributivity, the existential binding on the left
can be pulled through the tuple by \RSS{ExistLeft}.
Finally, \RSS{ExistRight} opens the existential on the right.

Once the algorithm reaches types on both sides,
i.e. \[ \subtysigdflt\ty{\ty'}, \]
subtyping should succeed if there is 
a valid substitution \substvars of unification variables from \UEnv
such that $\substvars(\ty) \symsub \substvars(\ty')$.
This is done in two steps (\RSS{Types}):
\begin{enumerate}
    \item constrained subtyping \subtyctrR{\AEnv}{\dom{\UEnv}}{\ty}{\ty'}{\CSet}
      generates constraints \CSet;
    \item \solvectrdflt resolves the constraints.
\end{enumerate}

When constrained subtyping (\figref{fig:subtyping-constrained}) takes over,
\[ \subtyctrRdflt{\ty}{\ty'}\ \text{ where }\ \UEnvD = \dom{\UEnv}, \]
the algorithm checks subtyping, possibly generating constraints 
\ctrsub{\tylb}{\va} and \ctrsub{\va}{\tyub} on
unification variables \va from \UEnvD, which may appear in $\ty'$.
This step ignores the declared unification variable bounds,
as emphasized by the environment \UEnvD as opposed to \UEnv.
Initially, all unification variables are located on the right,
which is indicated with $\bullet$ on the right of~$\symsubctrR$.
In the case of invariant constructors, the right-to-left subtyping check
is performed by \subtyctrLdflt{\ty'}{\ty}, with all unification variables
being located on the left.
Thus, constrained subtyping maintains the invariant that unification
variables always appear on at most one side of the subtyping judgment.
Because of this, generated constraints \tylb, \tyub are guaranteed to be 
\textbf{free from unification variables}.
Thus, the running example above continues as follows,
generating the constraint set {\ctrset{\ctrsub{\vx}{\va}, \ctrsub{\va}{\vx}}}.
\makebox[\textwidth][c]{
\begin{minipage}{\ruleswidth}
\begin{mathpar}
\small
\inferrule[]
{ 
    \inferrule[\footnotesize\RSC{Top}]
    { }
    { \subtyctrR{\vx{\symsub}\tyint}{\va}{\tyint}{\tyany}{\EmptyCSet} }
    \and
    \inferrule[]
    { 
        \inferrule[\footnotesize\RSC{UVarRight}]
        { }
        { \subtyctrR{\vx{\symsub}\tyint}{\va}
            {\vx}{\va}{\ctrset{\ctrsub{\vx}{\va}}}               
        }
        \and
        \inferrule[\footnotesize\RSC{UVarLeft}]
        { }
        { \subtyctrL{\vx{\symsub}\tyint}{\va}
            {\va}{\vx}{\ctrset{\ctrsub{\va}{\vx}}}
        }
    }
    { \subtyctrR{\vx{\symsub}\tyint}{\va}
        {\tyinv\nref\vx}
        {\tyinv\nref\va}
        {\ctrset{\ctrsub{\vx}{\va}, \ctrsub{\va}{\vx}}} }
}
{ \subtyctrR{\vx{\symsub}\tyint}{\va}
    {\typair{\tystr}{\tyinv\nref\vx}}
    {\typair{\tyany}{\tyinv\nref\va}}
    {\ctrset{\ctrsub{\vx}{\va}, \ctrsub{\va}{\vx}}}
}
\\
\end{mathpar}
\end{minipage}}

If constrained subtyping succeeds and generates a constraint set
\CSet, the constraints are resolved %with respect to \AEnv and \UEnv
by \solvectrdflt (\figref{fig:ctr-solve}).
Namely, all constraints on the same unification variable are checked for
consistency with each other and with the declared variable bounds from
\UEnv. If all the constraints are consistent, the variable is instantiated
with the smallest type---a union of all (declared and generated) lower bounds.
The consistency of constraints is checked with:
\begin{itemize}
    \item constrained subtyping \subtyctrLdflt{\tylb}{\ty} or
        \subtyctrRdflt{\ty}{\tyub}, to check that generated constraints \ty
        are consistent with declared bounds \tylb and \tyub;
        constrained subtyping is necessary because unification variable
        bounds may refer to other unification variables;
    \item unification-free subtyping of types \subtydflt{\tylb}{\tyub}
        (\figref{fig:subtyping-base}),
        to check that generated constraints are consistent with each other.
\end{itemize}
In the running example, the generated bound \vx of the unification variable \va
is trivially consistent with the declared bounds \tybot and \tyany;
furthermore, \subty{\vx{\symsub}\tyint}{\vx}{\vx} by reflexivity,
so the unification variable \va is instantiated with \vx.

In unification-free subtyping \subtydflt{\ty}{\ty'}, 
which is used for consistency checks,
variables are treated as universal. For example, with the exception of
the reflexive case, a variable \vany is a subtype of \ty only if the upper bound
\tyub of \vany is a subtype of \ty. This is similar to subtyping of
left/forall variables in \figref{fig:jlsubex}, \secref{sec:julia-sub:lambda-julia}.

% Once all existentials are processed, we run constraints-generating
% subtyping $\subtyctrdflt\ty{\ty'}$. It stands for either:
% \begin{itemize}
%     \item $\subtyctrRdflt\ty{\ty'}$ when unification variables are on the right, or
%     \item $\subtyctrLdflt\ty{\ty'}$ when unification variables are on the left.
% \end{itemize}
% We use \UEnvD rather than \UEnv to emphasize that declared bounds of unification
% variables are irrelevant for the judgment.

% Once all constraints are generated, they are resolved by \solvectrdflt
% primarily with $\subtydflt\ty{\ty'}$,
% subtyping of types that are free from unification vars.
% There is a caveat that declared bounds of unification vars need to be consistent
% with collected constraints, which is why constrained subtyping is used
% in constraints resolution.

\begin{figure}
\footnotesize
\[
\begin{array}{lccccccl}
    \dctxtysig &::=& \square &
        \Alt& \typair{\dctxtysig}{\tysig} &
        \Alt& \typair{\tysig}{\dctxtysig} &
        \textit{Distributivity context for type signatures}
    \\
    \dctxty &::=& \square &
        \Alt& \typair{\dctxty}{\ty} &
        \Alt& \typair{\ty}{\dctxty} &
        \textit{Distributivity context for types}
    \\
    \\
    \AEnv, \UEnv &::=& \EmptyEnv &
        \Alt& \AEnv, \varbound{\vany}{\tylb}{\tyub} &
        & & 
        \textit{Type variable environment}
    \\
    \UEnvD &::=& \EmptyEnv &
        \Alt& \UEnvD, \vany &
        & & 
        \textit{Type variable list}
    \\
    \\
    \CSet &::=& \multicolumn{3}{c}{
            \ctrset{\ctrsub{\tylb}{\va}, \ctrsub{\va}{\tyub}, \ldots}
        } & & &
        \textit{Constraint set}
\end{array}
\]
\caption{Auxiliary definitions}\label{fig:subty-aux}
\end{figure}
% \\
% \\
% \sty &::=& \tyany \Alt \tybot \Alt \vany &
%     \Alt& \typair{\sty_1}{\sty_2} &
%     \Alt& \tyinv\iname\rexvars &
%     \textit{Type without top-level unions}


Next, I present the exact definitions of:
\begin{itemize}
    \item unification-free subtyping of types \subtydflt{\ty}{\ty'};
    \item constrained subtyping of types \subtyctrdflt{\ty}{\ty'};
    \item constraints resolution \solvectrdflt;
    \item subtyping of type signatures \subtysigdflt{\tysig}{\tysig'}.
\end{itemize}

For simplicity of the presentation, I assume the following variable names 
convention based on Barendregt's convention:

\begin{definition}[Variable names convention]\label{def:var-names}
    Everywhere in definitions and proofs, the following conditions hold:
    \begin{itemize}
        \item all bound variables in \ty, \tysig are different from each other 
            and from free variables;
        \item all variables in \AEnv, \UEnv, \UEnvD are different 
            from each other;
        \item whenever both \AEnv and \UEnv or \AEnv and \UEnvD
            appear in the same judgment, 
            $\dom{\AEnv} \cap \dom{\UEnv} = \varnothing$ and
                $\dom{\AEnv} \cap \dom{\UEnvD} = \varnothing$;
        % \item whenever both \AEnv and \UEnv or \AEnv and \UEnvD
        %     appear in the same judgment:
        %     \begin{itemize}
        %         \item $\dom{\AEnv} \cap \dom{\UEnv} = \varnothing$ and
        %             $\dom{\AEnv} \cap \dom{\UEnvD} = \varnothing$;
        %         \item \AEnv contains only universal variables \vx, \vy, etc.,
        %             with their bounds also containing only universal variables;
        %         \item \UEnv and \UEnvD contain only unification variables
        %             \va, \vb, etc., with their bounds (for \UEnv) also
        %             containing only unification variables.
        %     \end{itemize}
        \item whenever a variable environment and a type/type signature
            appear in the same judgment, bound variables of the type/type
            signature are different from variables in the environment;
        \item whenever multiple types/type signatures appear in the same
            judgment, their bound variables are different.
    \end{itemize}
    These conditions can be maintained by alpha-renaming.
\end{definition}

% The convention about using different sets of variables for \AEnv and \UEnv/\UEnvD
% is not necessary, but it visually aids the perception of inference rules:
% whenever \va or \vb is used in a judgment,
% it is known to belong to \UEnv or \UEnvD.
% Without this convention, we would need to always check which environment
% the variable belongs to in order to discern its meaning.

%% Subtyping
%% *********************************************************

\subsection{Unification-Free Subtyping of Types}
%% *********************************************************

\begin{figure}
\footnotesize
\begin{mathpar}
    \fbox{\subtydflt{\ty}{\ty}}
    \\

    \inferrule[\RST{Top}]
    { }
    { \subtydflt{\ty}{\tyany} }

    \inferrule[\RST{Bot}]
    { }
    { \subtydflt{\plug\dctx\tybot}{\ty'} }
    \\

    \inferrule[\RST{VarRefl}]
    { \varbound{\vany}{\tylb}{\tyub} \in \AEnv }
    { \subtydflt{\vany}{\vany} }

    \inferrule[\RST{VarLeft}]
    { \varbound{\vany}{\tylb}{\tyub} \in \AEnv \and
        \subtydflt{\plug\dctx{\tyub}}{\ty'} }
    { \subtydflt{\plug{\dctx}\vany}{\ty'} }

    \inferrule[\RST{VarRight}]
    { \varbound{\vany}{\tylb}{\tyub} \in \AEnv \and
        \subtydflt\ty{\tylb} }
    { \subtydflt{\ty}{\vany} }
    \\

    \inferrule[\RST{Tuple}]
    { \subtydflt{\ty_1}{\ty'_1} \and \subtydflt{\ty_2}{\ty'_2} }
    { \subtydflt{\typair{\ty_1}{\ty_2}}{\typair{\ty'_1}{\ty'_2}} }

    % \inferrule*[]
    % { \inherits
    %     {\tyinv{\iname}{\vx_1,\ldots,\vx_n}}
    %     {\tyinv{\iname'}{\ty_1,\ldots,\ty_m}} \and
    %   \forall j \in 1..m.\ 
    %   \subtydflt
    %     {\subst{\ty_j}
    %         {\substel{\vx_1}{\rexvar_1},\ldots,\substel{\vx_n}{\rexvar_n}}}
    %     {\rexvar'_j} }
    % { \subtydflt
    %     {\tyinv\iname{\rexvar_1,\ldots,\rexvar_n}}
    %     {\tyinv{\iname'}{\rexvar'_1,\ldots,\rexvar'_m}} }

    \inferrule[\RST{Inv}]
    { \forall i \in 1..n. \and \subtydflt{\rexvar_i}{\rexvar'_i} }
    { \subtydflt
        {\tyinv\iname{\rexvar_1,\ldots,\rexvar_n}}
        {\tyinv\iname{\rexvar'_1,\ldots,\rexvar'_n}} }

    \inferrule[\RST{UnionLeft}]
    { \subtydflt{\plug\dctx{\ty_1}}{\ty'} \and 
        \subtydflt{\plug\dctx{\ty_2}}{\ty'} }
    { \subtydflt{\plug\dctx{\tyunion{\ty_1}{\ty_2}}}{\ty'} }

    \inferrule[\RST{UnionRight}]
    { \exists i.\ \ \subtydflt\ty{\ty'_i} }
    { \subtydflt{\ty}{\tyunion{\ty'_1}{\ty'_2}} }

    \\
    \fbox{\subtydflt{\rexvar}{\rexvar}}
    \\
    \inferrule*[]
    { \subtydflt{\tylb'}{\tylb} \and \subtydflt{\tyub}{\tyub'} }
    { \subtydflt
        {\rexvarbound{\tylb}{\tyub}}
        {\rexvarbound{\tylb'}{\tyub'}} }
    %
    \\
    \fbox{\subtydflt{\dctx}{\dctx}}
    \\

    \inferrule*[]
    { }
    { \subtydflt\square\square }

    \inferrule*[]
    { \subtydflt{\dctx_1}{\dctx'_1} \and \subtydflt{\ty_2}{\ty'_2} }
    { \subtydflt{\typair{\dctx_1}{\ty_2}}{\typair{\dctx'_1}{\ty'_2}} }

    \inferrule*[]
    { \subtydflt{\ty_1}{\ty'_1} \and \subtydflt{\dctx_2}{\dctx'_2} }
    { \subtydflt{\typair{\ty_1}{\dctx_2}}{\typair{\ty'_1}{\dctx'_2}} }
\end{mathpar}
\caption{Subtyping of types (free from unification variables)
    %Note: \dctx stands for \dctxty.
}\label{fig:subtyping-base}
\end{figure}

Unification-free subtyping of types is given in \figref{fig:subtyping-base}.

Following the semantic subtyping approach,
union types distribute over covariant tuples (\RST{UnionLeft}), 
and tuples containing the bottom type are subtypes of all types (\RST{Bot}).
Both of these rules are expressed with the distributivity context \dctx
defined in \figref{fig:subty-aux}, which allows unions and \tybot to be
``pulled through'' covariant tuples.
Although in Julia, only the proper bottom type \tybot is a subtype of all types
(but not \plug\dctx\tybot), I consider the more general \RST{Bot}
in accordance with semantic subtyping. To obtain Julia's semantics,
\RST{Bot} should be written as \subtydflt{\tybot}{\ty'}.

Subtyping of variables corresponds to the intuition that subtyping should
hold for all their valid instantiations. Thus, when a variable appears
covariantly on the left, it is replaced with the upper bound (\RST{VarLeft}).
When a variable appears on the right, it is replaced with the lower bound
(\RST{VarRight}).
The \RST{VarLeft} rule has to use the distributivity context, 
for the upper bound can be a union or bottom type. Without \dctx, the following
judgment would not be derivable:
\[
    \subty{\varbound{\vany}{\tybot}{(\tyunion{\tyint}{\tyflt})}}
        {\typair{\vany}{\tyany}}
        {\tyunion{\typair{\tyint}{\tyany}}{\typair{\tyflt}{\tyany}}}.
\]

Finally, subtyping of invariant constructors/restricted existential types
ensures that for each type parameter, the bounds on the left are contained
within the bounds on the right. This corresponds to the intuition that
for all valid instantiations of a variable on the left, there should be
a valid instantiation of a variable on the right.
For example, subtyping
\[
    \subty{}{\tyinv\nref{\rexvarbound{\tybot}{\tyint}}}
        {\tyinv\nref{\rexvarbound{\tybot}{\tyany}}}
\]
holds, whereas
\[
    \vdash \tyinv\nref{\rexvarbound{\tybot}{\tyint}} \nless:
    \tyinv\nref{\rexvarbound{\tyint}{\tyany}}
\]
does not.

Subtyping of distributivity contexts \subtydflt{\dctx}{\dctx'} is 
useful for proofs but is not used in the definition of \subtydflt{\ty}{\ty'}.

\subsection{Constrained Subtyping of Types}
%% *********************************************************

\begin{figure}
\footnotesize
\makebox[\textwidth][c]{
\begin{minipage}{\ruleswidth}  
\begin{mathpar}
    \fbox{\subtyctrdflt{\ty}{\ty}} 
    \\

    \inferrule[\RSC{Top}]
    { }
    { \subtyctrdfltenv{\ty}{\tyany}{\EmptyCSet} }

    \inferrule[\RSC{Bot}]
    { }
    { \subtyctrdfltenv{\plug\dctx\tybot}{\ty'}{\EmptyCSet} }

    \colorbox{light-gray}{$
    \inferrule[\RSC{UBot}]
    { \va \in \UEnvD }
    { \subtyctrLdfltenv{\plug\dctx\va}{\ty'}{\ctrsngl\va\tybot} }
    $}
    \\

    \inferrule[\RSC{VarRefl}]
    { \varbound{\vx}{\tylb}{\tyub} \in \AEnv }
    { \subtyctrdfltenv{\vx}{\vx}{\EmptyCSet} }

    \colorbox{light-gray}{$
    \inferrule[\RSC{UVarLeft}]
    { \va \in \UEnvD }
    { \subtyctrLdfltenv{\va}{\ty'}{\ctrsngl{\va}{\ty'}} }
    $}

    \colorbox{light-gray}{$
    \inferrule[\RSC{UVarRight}]
    { \va \in \UEnvD }
    { \subtyctrRdfltenv{\ty}{\va}{\ctrset{\ctrsub{\ty}{\va}}} }
    $}

    \inferrule[\RSC{VarLeft}]
    { \varbound{\vx}{\tylb}{\tyub} \in \AEnv \and
        \subtyctrdflt{\plug\dctx{\tyub}}{\ty'} }
    { \subtyctrdflt{\plug\dctx\vx}{\ty'} }

    \inferrule[\RSC{VarRight}]
    { \varbound{\vx}{\tylb}{\tyub} \in \AEnv \and
        \subtyctrdflt\ty{\tylb} }
    { \subtyctrdflt{\ty}{\vx} }
    \\

    \inferrule[\RSC{Tuple}]
    { \subtyctrdfltenv{\ty_1}{\ty'_1}{\CSet_1} \and 
        \subtyctrdfltenv{\ty_2}{\ty'_2}{\CSet_2} }
    { \subtyctrdfltenv{\typair{\ty_1}{\ty_2}}{\typair{\ty'_1}{\ty'_2}}
        {\CSet_1 \cup \CSet_2} }

    \inferrule[\RSC{Inv}]
    { \forall i \in 1..n. \and 
        \subtyctrdfltenv{\rexvar_i}{\rexvar'_i}{\CSet_i} }
    { \subtyctrdfltenv
        {\tyinv\iname{\rexvar_1,\ldots,\rexvar_n}}
        {\tyinv\iname{\rexvar'_1,\ldots,\rexvar'_n}}
        {\mcup_{i=1}^n \CSet_i} }
    \\

    \inferrule[\RSC{UnionLeft}]
    { \subtyctrdfltenv{\plug\dctx{\ty_1}}{\ty'}{\CSet_1} \and 
        \subtyctrdfltenv{\plug\dctx{\ty_2}}{\ty'}{\CSet_2} }
    { \subtyctrdfltenv{\plug\dctx{\tyunion{\ty_1}{\ty_2}}}{\ty'}
        {\CSet_1 \cup \CSet_2} }

    \inferrule[\RSC{UnionRight}]
    { \exists i.\ \ \subtyctrdflt\ty{\ty'_i} }
    { \subtyctrdflt{\ty}{\tyunion{\ty'_1}{\ty'_2}} }

    \colorbox{light-gray}{$
    \inferrule[\RSC{UVar-UnionRight}]
    {   \va \in \UEnvD \and \va_1, \va_2 \text{ fresh} \and
        \subtyctrL{\AEnv}{\UEnvD,\va_1}{\plug\dctx{\va_1}}{\ty'_1}{\CSet_1} \and
        \subtyctrL{\AEnv}{\UEnvD,\va_2}{\plug\dctx{\va_2}}{\ty'_2}{\CSet_2} \\ 
        \CSet_1 = \CSet'_1 \mcup_{i=1}^n \ctrset{\ctrsub{\va_1}{\tyub_1^i}} 
            \and \va_1 \notin \CSet'_1 \and
        \CSet_2 = \CSet'_2 \mcup_{j=1}^m \ctrset{\ctrsub{\va_2}{\tyub_2^j}} 
            \and \va_2 \notin \CSet'_2  \\
        \CSet'\ \ =\ \ 
            \ctrsngl{\va}{\tyunion{\msqcap_{i=1}^n \tyub_1^i}
                {\msqcap_{j=1}^m \tyub_2^j}} 
            \text{ if } n\geq1,m\geq1
        \text{\ or\ }
        \mcup_{i=1}^n \ctrset{\ctrsub{\va}{u_1^i}}\text{ if } m=0
        \text{\ or\ }
        \mcup_{j=1}^m \ctrset{\ctrsub{\va}{u_2^j}}\text{ if } n=0
    }
    { \subtyctrLdfltenv{\plug\dctx{\va}}{\tyunion{\ty'_1}{\ty'_2}}
        {\CSet'_1 \cup \CSet'_2 \cup \CSet'} }
    $}
%
    \\
    \fbox{\subtyctrdflt{\rexvar}{\rexvar}}
    \\

    \inferrule*[]
    { \subtyctrRdfltenv{\tylb'}{\tylb}{\CSet_l} \and 
        \subtyctrLdfltenv{\tyub}{\tyub'}{\CSet_u} }
    { \subtyctrLdfltenv
        {\rexvarbound{\tylb}{\tyub}}
        {\rexvarbound{\tylb'}{\tyub'}}
        {\CSet_l \cup \CSet_u} }

    \inferrule*[]
    { \subtyctrLdfltenv{\tylb'}{\tylb}{\CSet_l} \and 
        \subtyctrRdfltenv{\tyub}{\tyub'}{\CSet_u} }
    { \subtyctrRdfltenv
        {\rexvarbound{\tylb}{\tyub}}
        {\rexvarbound{\tylb'}{\tyub'}}
        {\CSet_l \cup \CSet_u} }
\end{mathpar}
\end{minipage}}
\caption{Constrained subtyping of types.
    Note: %\dctx stands for \dctxty;
    every rule with the symbol $\symsubctr$ is a shorthand for two rules, 
    one where all occurrences of $\symsubctr$ are replaced with 
    $\symsubctrL$, and another with $\symsubctrR$.
    Thus, the figure defines two mutually recursive relations,
    \subtyctrLdflt{\ty}{\ty'} and \subtyctrRdflt{\ty}{\ty'}.
    %$\symsubctr$ stands for either $\symsubctrL$ or $\symsubctrR$,
    %and within one rule, all occurrences of $\symsubctr$ denote the same relation
}\label{fig:subtyping-constrained}
\end{figure}
%% old definition of UVar-UnionRight: unclear how to prove its soundness
% \colorbox{light-gray}{$
% \inferrule[\RSC{UVar-UnionRight}]
% {   \va \in \UEnvD \and \va_1, \va_2 \text{ fresh} \and
%     \subtyctrL{\AEnv}{\UEnvD,\va_1}{\plug\dctx{\va_1}}{\ty'_1}{\CSet_1} \and
%     \subtyctrL{\AEnv}{\UEnvD,\va_2}{\plug\dctx{\va_2}}{\ty'_2}{\CSet_2} \\ 
%     \CSet_1 = \CSet'_1 \mcup_{i=1}^n \ctrset{\ctrsub{\va_1}{\tyub_1^i}} 
%         \and \va_1 \notin \CSet'_1 \and
%     \CSet_2 = \CSet'_2 \mcup_{j=1}^m \ctrset{\ctrsub{\va_2}{\tyub_2^j}} 
%         \and \va_2 \notin \CSet'_2  \\
%     \CSet'\ \ =\ \ \mcup_{i=1,j=1}^{i=n,j=m}
%         \ctrset{\ctrsub{\va}{\tyunion{\tyub_1^i}{\tyub_2^j}}}
%         \text{ if } n\geq1,m\geq1
%     \text{\ or\ }
%     \mcup_{i=1}^n \ctrset{\ctrsub{\va_1}{u_1^i}}\text{ if } m=0
%     \text{\ or\ }
%     \mcup_{j=1}^m \ctrset{\ctrsub{\va_2}{u_2^j}}\text{ if } n=0
% }
% { \subtyctrLdfltenv{\plug\dctx{\va}}{\tyunion{\ty'_1}{\ty'_2}}
%     {\CSet'_1 \cup \CSet'_2 \cup \CSet'} }
% $}


% \hline
% \multicolumn{6}{c}{\tyjoindflt{\ty}{\ty'}} \\ 
% \hline 
% \ty &\sqcup_{\AEnv}& \ty' &=& \ty' & \text{if } \subtydflt{\ty}{\ty'} \\
% \ty &\sqcup_{\AEnv}& \ty' &=& \ty  & \text{if } \subtydflt{\ty'}{\ty} \\
% \ty &\sqcup_{\AEnv}& \ty' &=& \tyunion{\ty}{\ty'} & \text{otherwise} \\
% \\
\begin{figure}
\footnotesize
\makebox[\textwidth][c]{
\begin{minipage}{\ruleswidth}  
\[
\begin{array}{ccccll}
    \hline
    \multicolumn{6}{c}{\tymeetdflt{\ty}{\ty'}} \\ 
    \hline 
    \ty &\sqcap_{\AEnv}& \ty' &=& \ty  & \text{ if } \subtydflt{\ty}{\ty'} \\
    \ty &\sqcap_{\AEnv}& \ty' &=& \ty' & \text{ if } \subtydflt{\ty'}{\ty} \\
    \tyunion{\ty_1}{\ty_2} &\sqcap_{\AEnv}& \ty' &=& 
        \tyunion{(\tymeetdflt{\ty_1}{\ty'})}{(\tymeetdflt{\ty_2}{\ty'})} &  \\
    \ty &\sqcap_{\AEnv}& \tyunion{\ty'_1}{\ty'_2} &=& 
        \tyunion{(\tymeetdflt{\ty}{\ty'_1})}{(\tymeetdflt{\ty}{\ty'_2})} &  \\
    \vany &\sqcap_{\AEnv}& \ty' &=& 
        \tymeetdflt{\tylb}{\ty'} & 
        \text{ where } \varbound{\vany}{\tylb}{\tyub} \in \AEnv \\
    \ty &\sqcap_{\AEnv}& \vany &=& 
        \tymeetdflt{\ty}{\tylb} & 
        \text{ where } \varbound{\vany}{\tylb}{\tyub} \in \AEnv \\
    \typair{\ty_1}{\ty_2} &\sqcap_{\AEnv}& \typair{\ty'_1}{\ty'_2} &=& 
        \typair{(\tymeetdflt{\ty_1}{\ty'_1})}{(\tymeetdflt{\ty_2}{\ty'_2})} &  \\
    \tyinv\iname{\ldots,\rexvarbound{\tylb_i}{\tyub_i},\ldots} 
        &\sqcap_{\AEnv}& \tyinv\iname{\ldots,\rexvarbound{\tylb'_i}{\tyub'_i},\ldots} &=& 
        \tyinv\iname{\ldots,\rexvarbound{(\tyjoindflt{\tylb_i}{\tylb'_i})}
            {(\tymeetdflt{\tyub_i}{\tyub'_i})},\ldots} &  \\
    & & & & \multicolumn{2}{l}{\text{where } \forall i.\ 
        \subtydflt{(\tyjoindflt{\tylb_i}{\tylb'_i})}
        {(\tymeetdflt{\tyub_i}{\tyub'_i})} } \\
    \ty &\sqcap_{\AEnv}& \ty' &=& \tybot & \text{otherwise} \\
\end{array}
\]
\end{minipage}}
\caption{Join ($\sqcup_{\AEnv}$) and meet ($\sqcap_{\AEnv}$) of types.
Both definitions should be read top to bottom, i.e. earlier cases have
precedence over later cases.
Some cases (e.g. where \ty or $\ty'$ are \tybot or \tyany, 
and where both are the same type variable)
are omitted because they are covered by \subtydflt{\ty}{\ty'} and 
\subtydflt{\ty'}{\ty}.}\label{fig:ty-join-meet}
\end{figure}



\begin{figure}
\footnotesize
\makebox[\textwidth][c]{
\begin{minipage}{\ruleswidth}
\begin{mathpar}
    \fbox{\subtysigdflt{\tysig}{\tysig}}
    \\

    \inferrule[\RSS{Top}]
    { }
    { \subtysigdflt{\tysig}{\tyany} }

    \inferrule[\RSS{Bot}]
    { }
    { \subtysigdflt{\plug\dctxsig\tybot}{\tysig'} }
    \\

    \inferrule[\RSS{VarLeft}]
    { \varbound{\vx}{\tylb}{\tyub} \in \AEnv \and
        \subtysigdflt{\plug\dctxsig{\tyub}}{\tysig'} }
    { \subtysigdflt{\plug\dctxsig\vx}{\tysig'} }

    \inferrule[\RSS{UnionLeft}]
    { \subtysigdflt{\plug\dctxsig{\tysig_1}}{\tysig'} \and 
        \subtysigdflt{\plug\dctxsig{\tysig_2}}{\tysig'}}
    { \subtysigdflt{\plug\dctxsig{\tyunion{\tysig_1}{\tysig_2}}}{\tysig'} }
    \\

    \inferrule[\RSS{InvLeft}]
    { \vx \text{ fresh} \and 
        \subtysig{\AEnv, \varbound{\vx}{\tylb}{\tyub}}{\UEnv}
        {\plug\dctxsig{\tyinv\iname{\ldots,\vx,\ldots}}}{\tysig'} }
    { \subtysigdflt{\plug\dctxsig{
        \tyinv\iname{\ldots,\rexvarbound{\tylb}{\tyub},\ldots}}}{\tysig'} }

    \inferrule[\RSS{ExistLeft}]
    { \subtysig{\AEnv, \varbound{\vx}{\tylb}{\tyub}}{\UEnv}{\plug\dctxsig\tysig}{\tysig'} }
    { \subtysigdflt{\plug\dctxsig{\tyexist{\vx}{\tylb}{\tyub}{\tysig}}}{\tysig'} }


    \inferrule[\RSS{UnionRight}]
    { \exists i.\ \subtysigdflt{\tysig}{\plug\dctxsig{\tysig'_i}} }
    { \subtysigdflt{\tysig}{\plug\dctxsig{\tyunion{\tysig'_1}{\tysig'_2}}} }

    \inferrule[\RSS{ExistRight}]
    { \subtysig{\AEnv}{\UEnv, \varbound{\va}{\tylb}{\tyub}}{\tysig}{\plug\dctxsig{\tysig'}} }
    { \subtysigdflt{\tysig}{\plug\dctxsig{\tyexist{\va}{\tylb}{\tyub}{\tysig'}}} }
    \\

    \inferrule[\RSS{Types}]
    { \subtyctrR{\AEnv}{\dom\UEnv}{\ty}{\ty'}{\CSet} \and
        \solvectrdflt = \substvars }
    { \subtysigdflt{\ty}{\ty'} }
\end{mathpar}
\end{minipage}}
\caption{Subtyping of type signatures
    %Note: \dctx stands for \dctxtysig.
}\label{fig:subtyping-tysigs}
\end{figure}


\begin{figure}
\footnotesize
\centering
\begin{minipage}{.7\linewidth}
\begin{algorithm}[H]
    \SetKwProg{SolveCtrs}{Solve}{}{}

    \SolveCtrs{$(\AEnv;\,\EmptyEnv;\,\CSet)$}{
        \KwRet{$\emptysubst$}
    }
    \BlankLine
    \SolveCtrs{$(\AEnv;\,\UEnv,\varbound{\va}{\tylb}{\tyub};\,\CSet)$}{
        $\CSet_{\va} \gets 
            \ctrset{\ctrsub{\tylb'}{\va} \,|\, \ctrsub{\tylb'}{\va} \in \CSet} 
            \cup 
            \ctrset{\ctrsub{\va}{\tyub'} \,|\, \ctrsub{\va}{\tyub'} \in \CSet} $ \;
        $\CSet' \gets \CSet \setminus \CSet_{\va}$ \;
        $\UEnvD \gets \dom{\UEnv}$\;
        \lForEach{$\ctrsub{\tylb_i}{\va}, \ctrsub{\va}{\tyub_j} \in \CSet_{\va}$}{%
            \subtydflt{\tylb_i}{\tyub_j}
        }
        \lForEach{$\ctrsub{\tylb_i}{\va} \in \CSet_{\va}$}{%
            \subtyctrRdfltenv{\tylb_i}{\tyub}{\CSet_{\tylb_i}}
        }
        \lForEach{$\ctrsub{\va}{\tyub_j} \in \CSet_{\va}$}{%
            \subtyctrLdfltenv{\tylb}{\tyub_j}{\CSet_{\tyub_j}}
        }
        $\substvars \gets \solvectr{\AEnv}{\UEnv}{
            \CSet' \mcup_i \CSet_{\tylb_i} \mcup_j \CSet_{\tyub_j}
        }$\;
        \KwRet{$\subst\substvars{\substel{\va}{
            \substvars(\tylb) \mcup_i \tylb_i
        }}$}
    }
    %$\substvars \gets \emptysubst$
\end{algorithm}  
\end{minipage}
\caption{Constraints resolution algorithm \solvectrdflt}\label{fig:ctr-solve}      
\end{figure}


%% Validity
%% *********************************************************

\begin{figure}
\footnotesize
\begin{mathpar}
    \fbox{\tyvlddflt{\ty}}
    \\

    \inferrule*[]
    { }
    { \tyvlddflt{\tyany} }

    \inferrule*[]
    { }
    { \tyvlddflt{\tybot} }

    \inferrule*[]
    { \varbound{\vany}{\tylb}{\tyub} \in \AEnv }
    { \tyvlddflt{\vany} }
    \\

    \inferrule*[]
    { \tyvlddflt{\ty_1} \and \tyvlddflt{\ty_2} }
    { \tyvlddflt{\typair{\ty_1}{\ty_2}} }

    \inferrule*[]
    { \iname \text{ has arity } n \and
      \forall i \in 1..n.\ \tyvlddflt{\rexvar_i} }
    { \tyvlddflt{\tyinv\iname{\rexvar_1,\ldots,\rexvar_n}} }

    \inferrule*[]
    { \tyvlddflt{\ty_1} \and \tyvlddflt{\ty_2} }
    { \tyvlddflt{\tyunion{\ty_1}{\ty_2}} }
    %
    \\
    \fbox{\tyvlddflt{\rexvar}}
    \\

    \inferrule*[]
    { \tyvlddflt{\tylb} \and \tyvlddflt{\tyub} \and 
        \subtydflt{\tylb}{\tyub} }
    { \tyvlddflt{\rexvarbound{\tylb}{\tyub}} }
    %
    \\
    \fbox{\tyvlddflt{\dctx}}
    \\

    \inferrule*[]
    { }
    { \tyvlddflt\square }

    \inferrule*[]
    { \tyvlddflt{\dctx} \and \tyvlddflt{\ty} }
    { \tyvlddflt{\typair{\dctx}{\ty}} }

    \inferrule*[]
    { \tyvlddflt{\ty} \and \tyvlddflt{\dctx} }
    { \tyvlddflt{\typair{\ty}{\dctx}} }
    %
    \\
    \fbox{\tyvlddflt{\tysig}}
    \\

    \inferrule*[]
    { }
    { \tyvlddflt{\tyany} }

    \ldots

    \inferrule*[]
    { \tyvlddflt{\tysig_1} \and \tyvlddflt{\tysig_2} }
    { \tyvlddflt{\tyunion{\tysig_1}{\tysig_2}} }

    \inferrule*[]
    { \tyvlddflt{\tylb} \and \tyvlddflt{\tyub} \and
        \subtydflt{\tylb}{\tyub} \and
        \tyvld{\AEnv, \varbound{\vany}{\tylb}{\tyub}}{\tysig} }
    { \tyvlddflt{\tyexist{\vany}{\tylb}{\tyub}{\tysig}} }
    %
    \\
    \fbox{\tyunfvlddflt{\ty}}
    \\

    \inferrule*[]
    { \varbound{\vx}{\tylb}{\tyub} \in \AEnv }
    { \tyunfvlddflt{\vx} }

    \inferrule*[]
    { \va \in \UEnvD }
    { \tyunfvlddflt{\va} }

    \inferrule*[]
    { }
    { \tyunfvlddflt{\tyany} }

    \ldots

    \inferrule*[]
    { \tyunfvlddflt{\ty_1} \and \tyunfvlddflt{\ty_2} }
    { \tyunfvlddflt{\tyunion{\ty_1}{\ty_2}} }
    %
    \\
    \fbox{\tyvld{}{\AEnv}}
    \\

    \inferrule*[]
    { }
    { \tyvld{}{\EmptyEnv} }

    \inferrule*[]
    { \tyvld{}{\AEnv} \and 
        \tyvlddflt{\tylb} \and \tyvlddflt{\tyub} \and
        \subtydflt{\tylb}{\tyub} }
    { \tyvld{}{\AEnv, \varbound{\vany}{\tylb}{\tyub}} }
\end{mathpar}
\caption{Validity of types and type signatures}\label{fig:ty-tysig-validity}
\end{figure}
% \inferrule*[]
% { }
% { \tyvlddflt{\tybot} }

% \inferrule*[]
% { \varbound{\vany}{\tylb}{\tyub} \in \AEnv }
% { \tyvlddflt{\vany} }

% \inferrule*[]
% { \iname \text{ has arity } n \and
%   \forall i \in 1..n.\ \tyvlddflt{\rexvar_i} }
% { \tyvlddflt{\tyinv\iname{\rexvar_1,\ldots,\rexvar_n}} }

% \inferrule*[]
% { \tyvlddflt{\tysig_1} \and \tyvlddflt{\tysig_2} }
% { \tyvlddflt{\typair{\tysig_1}{\tysig_2}} }

\begin{figure}
\footnotesize
\begin{mathpar}
    \fbox{\vldinenvdflt{\substvars}}
    \\

    \inferrule*[]
    { \forall \varbound{\vany}{\tylb}{\tyub} \in \AEnv. \and
        \tyvld{\AEnv'}{\substvars(\vany)} \and
        \subty{\AEnv'}{\substvars(\tylb)}{\substvars(\vany)} \and 
        \subty{\AEnv'}{\substvars(\vany)}{\substvars(\tyub)} }
    { \vldinenvdflt{\substvars} }
    
    \\
    \fbox{\vldinenv{\AEnv}{\CSet}{\substvars}}
    \\

    \inferrule*[]
    { \forall \ctrsub{\ty}{\va} \in \CSet.\ \ 
        \subtydflt{\ty}{\substvars(\va)} \and 
      \forall \ctrsub{\va}{\ty'} \in \CSet.\ \  
        \subtydflt{\substvars(\va)}{\ty'} }
    { \vldinenv{\AEnv}{\CSet}{\substvars} }
\end{mathpar}
\caption{Validity of substitution with respect to environment and constrains}%
\label{fig:substuvars-validity}
\end{figure}

Substitution is defined in the usual manner.

\textbf{The subtyping algorithm} is given by subtyping rules in
Figures~\ref{fig:subtyping-base,fig:subtyping-constrained,fig:subtyping-tysigs}
along with the constraints resolution algorithm in \figref{fig:ctr-solve}.
The rules are not syntax-directed because there may be multiple rules
applicable to a pair of types or type signatures,
but they are \emph{analytic}~\cite{bib:martin-lof:analytic-synthetic:1994}:
there is a finite number of applicable rules, and the premises of each rule
are comprised of the subcomponents of its conclusion.

\paragraph*{Overview of proofs.}
Subtyping is checked only for valid types/signatures.
The validity check ensures the absence of recursive constraints on type
variables as well as consistency of variable bounds.
For subtyping of types, we assume \tyvlddflt{\ty} and \tyvlddflt{\ty'}.
For subtyping of type signatures, we assume
\tyvlddflt{\tysig} and \tyvld{\concat{\AEnv}{\UEnv}}{\tysig'}.

\textbf{Termination.} The measure of a type includes the measure of its bounds.
In all subtyping judgments, every recursive call is made with a smaller measure.
For constraints resolution, every recursive call is made with a smaller \UEnv.

\textbf{Notes.}
Exists of unions is equivalent to the union of exists (in Julia subtyping),
so treating parts of the union on the right independently is correct
in subtyping of signatures.

Getting the upper bound of a universal variable might be needed at either the
signature or the type level, that's why the rules have some duplicates.
The key is to get rid of all top-level existentials.

Because the same semantic type can be represented with multiple syntactic types,
e.g. with an explicit existential vs restricted existential, it may be necessary
to open restricted existentials as top-level variables, but it is not always
necessary. That's why the rule for signature subtyping of invariant
constructor in a distibutivity context doesn't require all type arguments to be
specified as variables.

\input{chapters/sec-dec-sub-proofs.tex}
