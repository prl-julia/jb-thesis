\chapter{Proposed work}\label{chap:6}

\paragraph*{Decidable subtyping.}
I will show that
the decidability of subtyping can be achieved
for a type language similar to the one currently used by Julia,
with additional restrictions on existential types.
The restricted grammar of types is shown
in~\figref{fig:restricted-type-grammar}.
The key idea is to distinguish between more expressive \tysig and
less expressive \ty, with invariant parametric types $\iname\{\ldots\}$
being allowed to have only \ty as type arguments. In particular:
\begin{itemize}
  \item type signature \tysig, meant to represent method type signatures, is
  allowed to have a more expressive, Julia-style form of existential types where
  bound type variables can have multiple occurrences anywhere in the signature;
  to encode the diagonal rule, existential variables can be declared concrete
  (when kind $k$ is $c$), meaning that they can be instantiated only with
  concrete types;
  \item type \ty, meant to represent data, is allowed to have only a limited,
  Java wildcards-style form of existential types where type variables
  occur exactly once in an invariant position and are bound immediately outside
  the invariant costructor; namely, \tyinv{\iname}{\ty_l<:<\ty_u} represents
  an existential type \tyexist{X}{\ty_l}{\ty_u}{\tyinv{\iname}{\tyvar{X}}}.
\end{itemize}
In addition to being decidable, the proposed subtype relation
is intended to be reflexive and transitive,
as is typical for such a relation. Furthermore,
building on the indexed, tag-based interpretation of types, I will extend
it to account for type variables, and explore the relationship between
the extended model and the decidable, syntactic subtype relation.

%with the subtype relation matching set inclusion on the interpretations.
% Although Julia was inspired by semantic subtyping, the existing subtype relation
% is not consistent with the semantic approach: for example, the type 
% \cjl{Tuple\{Int, Union\{\}\}} (a covariant tuple of an integer and the bottom type)
% is not considered a subtype of the bottom type despite the fact that there are
% no values of type \cjl{Tuple\{Int, Union\{\}\}}.
% This inconsistency will be addressed in the subtype relation proposed
% in the thesis.

\begin{figure}[t]
\small
\[
\begin{array}{rcll}
  \tysig & ::= &
    \tybot \Alt \tyany \Alt
    \typair{\tysig}{\tysig} \Alt \tyunion{\tysig}{\tysig} \Alt
    \tyinv{\iname}{v,\ldots} \Alt
    \tyexist{\overset{k}{X}}{\ty}{\ty}{\tysig} \Alt \tyvar{X}
    & \text{type signature} \\
  \ty & ::= & 
    \tybot \Alt \tyany \Alt
    \typair{\ty}{\ty} \Alt \tyunion{\ty}{\ty} \Alt
    \tyinv{\iname}{v,\ldots} \Alt \tyvar{X}
    & \text{type} \\
  v & ::= &
    \ty<:<\ty
    & \text{restricted existential variable} \\
  k & ::= & a \Alt c & \text{variable kind (any | concrete)}
\end{array}
\]
\caption{Restricted grammar of Julia types}\label{fig:restricted-type-grammar}
\end{figure}

\paragraph*{Evaluation of migration effort.}
To evaluate the effort required for migrating existing code to a language
with the new subtype relation, I will conduct a static analysis of type
annotations in the official registry of Julia packages
(about 9000 packages as of March 2023).
In addition, I will manually inspect a random sample of packages containing
type annotations that do not conform to the new type language
and propose possible migration strategies.
Thus, for example, \cjl{Vector\{Dict\{T,T\} where T\}} (a vector
of dictionaries where keys and values are of the same type) is not expressible
under the restriction due to multiple occurrences of \cjl{T}.
Such a type can be replaced with a more permissive
\cjl{Vector\{Dict\{<:Any,<:Any\}\}}, which is a shorthand for
\cjl{Vector\{Dict\{K,V\} where K where V\}}. Then, the equality between
the types of keys and values can be checked at run time for each dictionary
in the vector.
As a second example, consider \cjl{Vector\{Vector\{Union\{T, Int\}\} where T\}},
which is not expressible due to \cjl{T} not being an immediate argument of
the inner \cjl{Vector}. Under Julia's subtyping, this type is equivalent
to \cjl{Vector\{Vector\{>:Int\}\}} (a shorthand for
\cjl{Vector\{Vector\{T\} where T>:Int\}}),
which is expressible in the new system.

\paragraph*{Paper submission.}
I intend to submit a POPL 2024 paper on the formalization and evaluation of
the decidable subtype relation.

\paragraph*{Schedule.}
I am currently working on proving the decidability, reflexivity,
and transitivity of the new subtype relation,
and intend to complete proofs in May 2023.
After that, I will perform the evaluation
and study an extension of the tag-based semantic interpretation
for types with type variables.
I will concurrently work on writing the thesis and the POPL 2024 paper
throughout May and June, and will finish the thesis in July.

\begin{table}[h]
  \caption{Schedule}
  \vspace*{0.25em}
  \centering\footnotesize
  \begin{tabular}{c|ccccc}
  \toprule
  & May & June & July & August \\
  \midrule
  proofs \& evaluation & X & X & & \\
  paper & X & X & & \\
  thesis & X & X & X & \\
  defense & & & & X \\
\end{tabular}
\end{table}





% I am currently working on designing a subtype relation
% and proving its decidability, reflexivity, and transitivity.
% I have also extended the interpretation of types to account for type variables.
% To evaluate the practicality of the subtype relation,
% I will perform a static analysis of type annotations in registered Julia
% packages (about 9000 as of March 2023).

% In July 2023, I intend to submit a POPL 2024 paper on decidable subtyping
% and complete my thesis, defending in August 2023.

% \begin{table}[h]
%   \caption{Schedule}
%   \vspace*{0.25em}
%   \centering\footnotesize
%   \begin{tabular}{c|ccccc}
%   \toprule
%   & May & June & July & August \\
%   \midrule
%   proofs \& evaluation & X & X & & \\
%   paper & X & X & & \\
%   thesis & X & X & X & \\
%   defense & & & & X \\
% \end{tabular}
% \end{table}

% I plan to work on developing a decidable subtyping specification for the Julia
% language and write a research paper on that.
% As outlined in \chapref{chap:3}, I envision the type language to be close to the
% one currently used in Julia, with some restrictions that ensure decidability
% but support the majority of the existing code base.
% As a first step, I will look into restricting lower bounds of existential type
% variables, for lower bounds make it possible to encode the undecidable
% system \FSub in Julia. Furthermore, taking into account the inconsistent
% treatment of types due to the diagonal rule,
% and the importance of concrete types for optimizations in the JIT compiler,
% I propose to explicitly distinguish between regular existential types
% and existential types where the type variable ranges over only concrete types.

% I intend to do the technical work on decidable subtyping and submit a paper
% for POPL 2023, with the deadline in July 2022.
% After that, I intend to collaborate with the Julia developers on incorporating
% decidable subtyping into the Julia language and work on the thesis.
% I expect that the thesis will be completed in a year from the proposal time,
% around February 2023.


% \begin{figure}
% \small
% \makebox[\textwidth]{
% \begin{tabular}{l@{\hspace{4mm}}l}
%   $\begin{array}{rcll}
%     \ty
%       &::=& & \textit{Type annotations} \\
%       &\Alt& \tyany & \text{top type} \\
%       &\Alt& \tybot & \text{bottom type} \\
%       &\Alt& \typair{\ty_1}{\ty_2}
%                     & \text{covariant pair} \\
%       &\Alt& \tyinv\iname\tys
%                     & \text{invariant constr.} \\
%       &\Alt& \tyexist{X}{\cty_l}{\ty_u}{\ty}
%                     & \text{existential type} \\
%       &\Alt& \tvx   & \text{type variable} \\
%       &\Alt& \gtyexist{X}{\ty_u}{\ty}
%                     & \text{concretely-exist. type} \\
%       &\Alt& \gvx   & \text{concrete type var.} \\
%       &\Alt& \tyunion{\ty_1}{\ty_2}
%                     & \text{union type} \\
%     \\
%     \cty  &::=& \ty  \Alt \fv\ty  = \varnothing & \textit{Closed types} \\
%   \end{array}$
% &
%   $\begin{array}{rcll}
%     \gty
%       &::=& & \textit{Type tags} \\
%       &\Alt& \tyinv\cname\tys
%                     & \text{concr. inv. constr.} \\
%       &\Alt& \typair{\gty_1}{\gty_2}
%                     & \text{concrete pair} \\
%       &\Alt& \gvx   & \text{concrete type var.} \\
%     \\\\
%     \iname
%       &::=& & \textit{User-defined names} \\
%       &\Alt& \cname & \text{concrete} \\
%       &\Alt& \aname & \text{abstract} \\
      
%     \\\\
%     \cgty &::=& \gty \Alt \fv\gty = \varnothing & \textit{Closed tags} \\
%   \end{array}$
% \end{tabular}
% }\caption{Syntax}\label{fig:syntax}
% \end{figure}

% \begin{figure}
% \small

%   \[ \VEnv ::= \EmptyEnv \Alt \VEnv, \var{X} \]

% \begin{mathpar}
%   \fbox{\wlscpd{\ty}}
%   \\

%   \inferrule{ }
%   { \wlscpd{\tyany} }

%   \inferrule{ }
%   { \wlscpd{\tybot} }
%   \\

%   \inferrule
%   { \wlscpd{\ty_1} \and \wlscpd{\ty_2} }
%   { \wlscpd{ \typair{\ty_1}{\ty_2} } }

%   \inferrule
%   { \forall i.\ \cfbox{light-gray}{\wlfrscpd{\ty_i}} }
%   { \wlscpd{ \tyinv\iname\tys } }

%   \inferrule
%   { \wlscpd{\ty_1} \and \wlscpd{\ty_2} }
%   { \wlscpd{ \tyunion{\ty_1}{\ty_2} } }
%   \\

%   \inferrule
%   { \wlscp{\EmptyEnv}{\cty_l} \and \wlscpd{\ty_u} \and \wlscp{\VEnv,\vx}{\ty} }
%   { \wlscpd{ \tyexist{X}{\cty_l}{\ty_u}{\ty} } }

%   \inferrule
%   { \wlscpd{\ty_u} \and \wlscp{\VEnv,\vx}{\ty} }
%   { \wlscpd{ \gtyexist{X}{\ty_u}{\ty} } }
  
%   \inferrule
%   { \vx \in \dom\VEnv }
%   { \wlscpd{\avx} }
%   \\

%   \fbox{\wlfrscpd{\ty}}
%   \\

%   \inferrule{ }
%   { \wlfrscpd{\tyany} }

%   \inferrule{ }
%   { \wlfrscpd{\tybot} }
%   \\

%   \inferrule
%   { \wlfrscpd{\ty_1} \and \wlfrscpd{\ty_2} }
%   { \wlfrscpd{ \typair{\ty_1}{\ty_2} } }

%   \inferrule
%   { \forall i.\ \wlfrscpd{\ty_i} }
%   { \wlfrscpd{ \tyinv\iname\tys } }

%   \inferrule
%   { \cfbox{light-gray}{$\wlscp{\colorbox{light-gray}{\EmptyEnv}}{\ty_1}$} \and
%     \cfbox{light-gray}{$\wlscp{\colorbox{light-gray}{\EmptyEnv}}{\ty_2}$} }
%   { \wlfrscpd{ \tyunion{\ty_1}{\ty_2} } }
%   \\

%   \inferrule
%   { \cfbox{light-gray}{\wlscp{\EmptyEnv}{\cty_l}} \and
%     \cfbox{light-gray}{$\wlscp{\colorbox{light-gray}{\EmptyEnv}}{\ty_u}$} \and
%     \cfbox{light-gray}{$\wlscp{\colorbox{light-gray}{\vx}}{\ty}$} }
%   { \wlfrscpd{ \tyexist{X}{\cty_l}{\ty_u}{\ty} } }

%   \inferrule
%   { \cfbox{light-gray}{$\wlscp{\colorbox{light-gray}{\EmptyEnv}}{\ty_u}$} \and
%     \cfbox{light-gray}{$\wlscp{\colorbox{light-gray}{\vx}}{\ty}$} }
%   { \wlfrscpd{ \gtyexist{X}{\ty_u}{\ty} } }

%   \inferrule
%   { \vx \in \dom\VEnv }
%   { \wlfrscpd{\avx} }
  
% \end{mathpar}

% \caption{Well scopedness}\label{fig:well-scope}
% \end{figure}




